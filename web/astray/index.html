<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Moral Maze - Astray Web</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="/web/Box2dWeb.min.js"></script>
    <script src="/web/Three.js"></script>
    <script src="/web/keyboard.js"></script>
    <script src="/web/jquery.js"></script>
    <style>
        :root {
            color-scheme: dark;
            font-family: "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            color: #f0f0f0;
        }

        #hud {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 10;
            display: grid;
            gap: 10px;
            width: 240px;
        }
        .hud-card {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            padding: 10px 14px;
            backdrop-filter: blur(4px);
        }
        .hud-card h2 {
            margin: 0 0 6px;
            font-size: 14px;
            font-weight: 700;
            color: #ffd56b;
        }
        .info-card h2 {
            color: #ffd56b;
        }
        .hero-card h2 {
            color: #f7c948;
        }
        .buddy-card h2 {
            color: #7ac5ff;
        }
        .hud-card .row {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin: 2px 0;
        }
        .hero-card .row:nth-child(2) span { color: #f7c948; } /* jumps */
        .hero-card .row:nth-child(3) span { color: #9ad0ff; } /* shield */
        .hero-card .row:nth-child(4) span { color: #8de38d; } /* escape */
        .hero-card .row strong { color: #fff; }
        .buddy-card .row:nth-child(2) span { color: #7ac5ff; } /* jumps */
        .buddy-card .row:nth-child(3) span { color: #8bd7ff; } /* freeze */
        .buddy-card .row:nth-child(4) span { color: #7dffaf; } /* frontier */
        .buddy-card .row:nth-child(5) span { color: #ff9dd6; } /* dissolve */
        .buddy-card .row:nth-child(6) span { color: #f7c948; } /* lift */
        .buddy-card .row:nth-child(7) span { color: #ff8c6b; } /* trap */
        .buddy-card .row:nth-child(8) span { color: #bca4ff; } /* blink */
        .trait.empathy { color: #9ad0ff; }
        .trait.integrity { color: #ffd56b; }
        .trait.courage { color: #ff8c6b; }
        .trait.responsibility { color: #8de38d; }
        .trait.independence { color: #bca4ff; }

        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 18px;
            border-radius: 999px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 20;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 30;
        }

        .modal.hidden {
            display: none;
        }

        .modal-card {
            background: #111;
            border-radius: 16px;
            padding: 24px;
            width: min(640px, 90vw);
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .modal-card h2 {
            margin-top: 0;
            font-size: 20px;
            color: #ffd56b;
        }

        .options button {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 10px 12px;
            border-radius: 8px;
            color: inherit;
            text-align: left;
            margin-bottom: 8px;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
        }

        .options button.active {
            border-color: #ffd56b;
            background: rgba(255, 213, 107, 0.15);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 18px;
        }
        /* Stack decision actions vertically to separate Submit */
        #decision-modal .modal-actions {
            flex-direction: column;
            align-items: flex-end;
        }
        /* Uniform button sizing for decision actions */
        #decision-modal .modal-actions .btn {
            min-width: 140px;
            text-align: center;
        }

        .btn {
            border: none;
            border-radius: 10px;
            padding: 10px 18px;
            font-size: 14px;
            cursor: pointer;
        }

        .btn.primary {
            background: linear-gradient(120deg, #ffb347, #ffcc33);
            color: #1a1a1a;
        }

        .btn.secondary {
            background: rgba(255, 255, 255, 0.08);
            color: #f0f0f0;
        }

        .is-hidden {
            display: none !important;
        }

        #loading-mask {
            position: fixed;
            inset: 0;
            background: #050505;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 40;
        }

        #loading-mask.hidden {
            display: none;
        }

        #loading-mask .panel {
            text-align: center;
        }

        #loading-mask h1 {
            color: #ffd56b;
            margin-bottom: 8px;
        }

        #timeline-modal .modal-card {
            width: min(900px, 95vw);
        }

        #timeline-scroll {
            max-height: 65vh;
            overflow-y: auto;
            padding-right: 6px;
        }

        .review-card {
            margin-top: 10px;
            padding: 14px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .review-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 8px;
            margin: 10px 0;
        }

        .review-tile {
            padding: 8px 10px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 13px;
            color: #e6e6e6;
        }

        .review-tile strong {
            display: block;
            color: #ffd56b;
            margin-bottom: 2px;
        }

        .voices p {
            margin: 4px 0;
            font-size: 13px;
            color: #d0d0d0;
        }

        .wait-card {
            margin-top: 12px;
            padding: 14px;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.08);
            text-align: center;
        }

        .wait-card h3 {
            margin: 0 0 8px;
            color: #ffd56b;
        }

        .wait-card p {
            margin: 6px 0;
            color: #e6e6e6;
            font-size: 14px;
        }

        .wait-card .label {
            color: #9ad0ff;
            font-size: 13px;
            margin-bottom: 4px;
        }

        #decision-intro {
            color: #4da3ff;
            margin: 0 0 10px;
            font-size: 14px;
        }

        .wait-actions {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        .gp-focus {
            outline: 2px solid #ffd56b;
            outline-offset: 2px;
            border-radius: 8px;
        }

        .timeline-item {
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            padding: 12px 0;
        }

        .timeline-item:last-child {
            border-bottom: none;
        }

        .timeline-item h4 {
            margin: 0 0 6px;
            font-size: 15px;
            color: #ffd56b;
        }

        .timeline-item p {
            margin: 4px 0;
            font-size: 13px;
            color: #d0d0d0;
        }

        /* Intro overlay */
        #intro-modal .modal-card {
            max-width: 860px;
            background: radial-gradient(circle at 20% 20%, rgba(255, 213, 107, 0.12), rgba(0, 0, 0, 0.85));
            border: 1px solid rgba(255, 213, 107, 0.2);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
        }
        .intro-pill {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(77, 163, 255, 0.12);
            color: #9ad0ff;
            font-size: 12px;
            letter-spacing: 0.02em;
            margin-bottom: 6px;
        }
        .intro-lead {
            margin: 6px 0 16px;
            color: #e6e6e6;
            font-size: 15px;
        }
        .intro-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
            margin-top: 10px;
        }
        .intro-card-item {
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.07);
            background: rgba(255, 255, 255, 0.02);
        }
        .intro-card-item h4 {
            margin: 0 0 6px;
            color: #ffd56b;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .intro-card-item p {
            margin: 0;
            color: #d8d8d8;
            font-size: 13px;
            line-height: 1.35;
        }
        .intro-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .intro-list li {
            color: #d8d8d8;
            font-size: 13px;
            line-height: 1.35;
        }
        .intro-list .tag {
            color: #9ad0ff;
            margin-right: 6px;
            font-weight: 600;
        }
        .intro-actions {
            margin-top: 16px;
            display: flex;
            justify-content: flex-end;
        }
    </style>
</head>

<body>
    <div id="intro-modal" class="modal hidden">
        <div class="modal-card">
            <span class="intro-pill">Moral Maze · Quick Brief</span>
            <h2>Grow through dilemmas</h2>
            <p class="intro-lead">Guide the yellow orb through shifting mazes. At glowing rings, face age-tuned life or moral dilemmas that shape your journey.</p>
            <div class="intro-grid">
                <div class="intro-card-item">
                    <h4>🟡 Hero (Yellow)</h4>
                    <ul class="intro-list">
                        <li><span class="tag">Jump</span>🎮 A (hold + direction) · ⚡ Vault over walls.</li>
                        <li><span class="tag">Shield</span>🎮 X · ⚡ Block incoming damage briefly.</li>
                        <li><span class="tag">Escape</span>🎮 B · ⚡ Break freeze/lift when available.</li>
                    </ul>
                </div>
                <div class="intro-card-item">
                    <h4>🔵 Buddy (Blue)</h4>
                    <ul class="intro-list">
                        <li><span class="tag">Freeze</span>🎮 X · ⚡ Freeze hero 5s and -5% HP.</li>
                        <li><span class="tag">Frontier</span>🎮 Y · ⚡ Carve a path forward.</li>
                        <li><span class="tag">Lift</span>🎮 B · ⚡ Pull hero in; A throws 2–3 tiles; B sends a roll until a wall; out-of-bounds is lethal.</li>
                        <li><span class="tag">Trap</span>🎮 LT = 80% mine: -30 HP / 20% medkit: +20 HP; 🎮 LB = 80% medkit: +20 HP / 20% mine: -30 HP.</li>
                        <li><span class="tag">Dissolve</span>🎮 RT · ⚡ Temporarily remove a decision node.</li>
                        <li><span class="tag">Blink</span>🎮 RB · ⚡ Short teleport to reposition.</li>
                    </ul>
                </div>
                <div class="intro-card-item">
                    <h4>✨ Dilemmas</h4>
                    <p>Step into yellow glow to answer. Prompts mirror your age; options aren’t good or bad—pick your value path.</p>
                </div>
                <div class="intro-card-item">
                    <h4>🎯 Goal</h4>
                    <p>Reach your goal age while managing health, jumps, and choices. Each decision updates growth, stage, and shield/jump economy.</p>
                </div>
            </div>
            <div class="intro-actions">
                <button class="btn primary" id="intro-start">Enter the Maze</button>
            </div>
        </div>
    </div>

    <div id="hud"></div>`n`n    <div id="toast"></div>

    <div id="loading-mask">
        <div class="panel">
            <h1>Waking the Moral Maze...</h1>
            <div id="loading-text">Linking backend...</div>
        </div>
    </div>

    <div id="start-choice" class="modal hidden">
        <div class="modal-card">
            <h2>Choose Your Start</h2>
            <p id="start-choice-info">Save detected. Continue or restart?</p>
            <div class="modal-actions">
                <button class="btn secondary" id="start-continue">Continue Journey</button>
                <button class="btn primary" id="start-restart">Restart</button>
            </div>
        </div>
    </div>

    <div id="decision-modal" class="modal hidden">
        <div class="modal-card">
            <h2>New Dilemma</h2>
            <div id="decision-question">
                <p class="label" id="decision-intro"></p>
                <p id="decision-prompt"></p>
                <div class="options" id="decision-options"></div>
                <div class="modal-actions">
                    <button class="btn primary" id="decision-submit">Submit</button>
                </div>
            </div>
            <div id="decision-wait" class="is-hidden">
                <div class="wait-card">
                    <h3 id="wait-title">AI is crafting your review...</h3>
                    <p class="label" id="wait-label"></p>
                    <p id="wait-en"></p>
                    <p id="wait-cn"></p>
                    <div class="wait-actions is-hidden" id="wait-actions">
                        <button class="btn primary" id="wait-view">View Review</button>
                    </div>
                </div>
            </div>
            <div id="decision-review" class="is-hidden">
                <div class="review-card">
                    <h3>AI Review</h3>
                    <p id="review-growth"></p>
                    <p id="review-score"></p>
                    <div class="review-grid" id="review-values"></div>
                    <p id="review-feedback"></p>
                    <div class="voices">
                        <p><strong id="label-parents">Parents:</strong> <span id="voice-parents"></span></p>
                        <p><strong>Friend:</strong> <span id="voice-friend"></span></p>
                        <p><strong id="label-future">Future self:</strong> <span id="voice-future"></span></p>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="btn primary" id="review-continue">Continue</button>
                </div>
            </div>
        </div>
    </div>

    <div id="timeline-modal" class="modal hidden">
        <div class="modal-card">
            <h2>Life Recap</h2>
            <div id="timeline-scroll">
                <div id="timeline-summary"></div>
                <div id="timeline-narrative"></div>
                <div id="timeline-list"></div>
            </div>
            <div class="modal-actions">
                <button class="btn primary" id="timeline-restart">Restart</button>
            </div>
        </div>
    </div>

    <script>
        // Box2D shortcuts
        const b2World = Box2D.Dynamics.b2World;
        const b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
        const b2BodyDef = Box2D.Dynamics.b2BodyDef;
        const b2Body = Box2D.Dynamics.b2Body;
        const b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
        const b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
        const b2Vec2 = Box2D.Common.Math.b2Vec2;

        const API_BASE = window.API_BASE || "";
        const ballRadius = 0.25;
        const ironTexture = THREE.ImageUtils.loadTexture('/web/ball.png');
        const planeTexture = THREE.ImageUtils.loadTexture('/web/concrete.png');
        const brickTexture = THREE.ImageUtils.loadTexture('/web/brick.png');
        const wallGeometry = new THREE.CubeGeometry(1, 1, 1, 1, 1, 1);
        const wallMaterial = new THREE.MeshPhongMaterial({ map: brickTexture });
        const MUTATION_DIRS = [
            { dx: 1, dy: 0 },
            { dx: -1, dy: 0 },
            { dx: 0, dy: 1 },
            { dx: 0, dy: -1 }
        ];
        const CELL_DIRS = {
            north: { dx: 0, dy: -1, opposite: 'south' },
            south: { dx: 0, dy: 1, opposite: 'north' },
            east: { dx: 1, dy: 0, opposite: 'west' },
            west: { dx: -1, dy: 0, opposite: 'east' },
        };

        let renderer, scene, camera, light, wWorld, wBall, mazeMesh, planeMesh, ballMesh;
        let mazeData = null;
        let stateData = null;
        let gamePhase = 'loading';
        let decisionQuestion = null;
        let currentCell = null;
        let serverCell = null;
        let pendingMove = false;
        const offlineMoveQueue = [];
        let offlineSyncPromise = null;
        const decisionMarkers = new Map();
        const wallBodies = new Map();
        const wallMeshes = new Map();
        let keyAxis = [0, 0];
let allyAxis = [0, 0];
let decisionStatus = 'idle'; // idle -> loading_question -> showing_question -> waiting_review -> showing_review
let pendingDecisionPosition = null;
let pendingTimeline = false;
let reviewDelayTimer = null;
let pendingReviewPayload = null;
let reviewReady = false;
let pendingHeroDeath = false;
let lastFrameTime = performance.now();
let mazeWavePhase = 0;
let mazeMutationTimer = 0;
const mutationInterval = 1.1;
const mutationsPerInterval = 4;
const removalChance = 0.8;
const relocationChance = 0.35;
const removalWarningDuration = 1.2; // seconds before a wall vanishes
const additionHighlightDuration = 2.5;
const removalHighlightColor = 0xbf5bff; // purple for disappearing walls
const additionHighlightColor = 0xff3366; // red for newly added walls
const allyJumpInterval = 15;
const allyJumpMax = 4;
const AGE_REFLECTIONS = [
    {
        min: 10, max: 19,
        lines: [
            { en: "You begin to see the world as bigger than your home, yet smaller than your dreams.", cn: "天高地迥，觉宇宙之无穷。" },
            { en: "You try on many versions of yourself, searching for the one that feels real.", cn: "欲穷千里目，更上一层楼。" },
            { en: "Feelings come fast and strong, teaching you how wide a heart can open.", cn: "少年不识愁滋味。" },
            { en: "You learn that growing up is not about answers, but about learning to ask better questions.", cn: "学然后知不足。" },
        ]
    },
    {
        min: 20, max: 29,
        lines: [
            { en: "You step into the world with hope in your hands, not knowing which hopes will stay.", cn: "长风破浪会有时。" },
            { en: "Freedom feels exciting until you realize it asks you to choose who you want to be.", cn: "路漫漫其修远兮，吾将上下而求索。" },
            { en: "Some paths close, others open, and each choice shapes a new part of you.", cn: "沉舟侧畔千帆过，病树前头万木春。" },
            { en: "You learn that it is okay not to have everything figured out.", cn: "山重水复疑无路，柳暗花明又一村。" },
        ]
    },
    {
        min: 30, max: 39,
        lines: [
            { en: "You work hard not just for success, but for a life that feels honest and steady.", cn: "但愿人长久，千里共婵娟。" },
            { en: "You begin to understand what truly matters and what was only noise.", cn: "淡泊以明志，宁静以致远。" },
            { en: "Time starts to move quickly, reminding you to hold on to what you love.", cn: "逝者如斯夫，不舍昼夜。" },
            { en: "You learn that strength is not loud; it is quiet, patient, and kind.", cn: "大音希声，大象无形。" },
        ]
    },
    {
        min: 40, max: 49,
        lines: [
            { en: "You see that life is not a race, but a journey that needs courage to walk slowly.", cn: "行到水穷处，坐看云起时。" },
            { en: "The past becomes clearer, and so do the choices you still want to make.", cn: "回首向来萧瑟处，归去，也无风雨也无晴。" },
            { en: "You learn to listen to yourself with more trust and less doubt.", cn: "莫听穿林打叶声，何妨吟啸且徐行。" },
            { en: "You understand that real change often begins in small, honest steps.", cn: "不积跬步，无以至千里。" },
        ]
    },
    {
        min: 50, max: 59,
        lines: [
            { en: "You look back with softer eyes, seeing mistakes as lessons, not failures.", cn: "江流天地外，山色有无中。" },
            { en: "You learn that peace grows when you stop trying to control everything.", cn: "随遇而安。" },
            { en: "Joy comes from simple things—warm voices, quiet mornings, shared meals.", cn: "柴门闻犬吠，风雪夜归人。" },
            { en: "You start to carry your life with more gratitude and less hurry.", cn: "采菊东篱下，悠然见南山。" },
        ]
    },
    {
        min: 60, max: 69,
        lines: [
            { en: "You finally have time to breathe, and your days feel calm and full.", cn: "结庐在人境，而无车马喧。" },
            { en: "Memories arrive gently, showing you how far you have come.", cn: "浮生若梦，为欢几何。" },
            { en: "You learn that forgiveness is a gift you give to yourself first.", cn: "桃李春风一杯酒，江湖夜雨十年灯。" },
            { en: "You begin to value presence more than plans.", cn: "人闲桂花落，夜静春山空。" },
        ]
    },
    {
        min: 70, max: 79,
        lines: [
            { en: "You move more slowly, but your understanding grows deeper.", cn: "老骥伏枥，志在千里。" },
            { en: "The world feels quieter, and the quiet feels kind.", cn: "明月松间照，清泉石上流。" },
            { en: "You treasure familiar faces more than ever before.", cn: "人生贵相知。" },
            { en: "You learn that love stays even when many other things fade.", cn: "相见亦无事，不来常思君。" },
        ]
    },
    {
        min: 80, max: 89,
        lines: [
            { en: "You look at life with calm eyes, thankful for every day that arrives.", cn: "但愿人长久。" },
            { en: "You see clearly that people mattered more than achievements.", cn: "桃李不言，下自成蹊。" },
            { en: "Small moments—light, laughter, touch—shine brighter than ever.", cn: "时光静好，与君语。" },
            { en: "You understand that every age was a chapter, and each one had its own beauty.", cn: "年年岁岁花相似，岁岁年年人不同。" },
        ]
    },
];
        let jumpCharges = 0;
        let jumpPrimed = false;
        let pendingJump = false;
        let isJumping = false;
        let jumpAnimation = null;
        let heroFixture = null;
        let heroBaseDensity = 1;
        let heroMassScale = 1;
        let heroFrozenImpulseBoost = 1;
        let allyJumpPrimed = false;
        let pendingAllyJump = false;
        const jumpAnimationDuration = 0.65;
        const jumpArcHeight = 2.5;
        let freezeCharges = 0;
        let freezePrimed = false;
        let freezeRechargeTimer = 0;
        let freezeInitialDelay = 10;
        let freezeInterval = 30;
        let freezeInitialGranted = false;
        let freezeBeam = null;
        let freezeBeamTimer = 0;
        let heroFrozen = false;
        let heroFreezeTimer = 0;
        let freezeOverlay = null;
        let expandCharges = 0;
        let expandPrimed = false;
        let expandRechargeTimer = 0;
        let expandInitialDelay = 10;
        let expandInterval = 20;
        let expandInitialGranted = false;
        let expandBurstAmount = 2;
        let expandMaxCharges = 5;
        const expandRestoreDelay = 20;
        const expandMaxDistance = 8;
        let cellGrid = null;
        const pendingWallMutations = [];
        let mutationSyncPromise = null;
        const wallHighlightStates = new Map();
        const scheduledWallMutations = [];
        let allyBody = null;
        let allyMesh = null;
        let allyGlow = null;
        let allyJumpCharges = 2;
        let allyJumpTimer = 0;
        let isAllyJumping = false;
        let allyJumpAnimation = null;
        let dissolveCharges = 1;
        let dissolveTimer = 0;
        const dissolveInterval = 15;
        const dissolveMax = 2;
        const expandRestoreQueue = [];
        const expandWaveEffects = [];
        const dissolvedMap = new Map(); // key -> restoreAt
        let heroHealth = 100;
        let trapCharges = 1;
        let trapTimer = 0;
        const trapInterval = 20;
        const trapMax = 2;
        const trapVisuals = new Map();
        let blinkCharges = 1;
        let blinkTimer = 0;
        const blinkInterval = 20;
        const blinkMax = 2;
        let blinkAnim = null;
        let allyBlinkActive = false;
        let escapeCharges = 0;
        const collapseEffects = [];
        let heroDead = false;
        let rollingActive = false;
        let rollingDir = 'east';
        const rollingSpeed = 6; // tiles per second
        const rollingBounce = 0.3;
        const rollingMinClearance = 0.5 + ballRadius + 0.1; // ensure out of wall
        let lastRollSafeCell = null;
        let lastRollPos = null;
        let allyGlowFlicker = 0;
        let allyDisabledDuringHeroJump = false;
        // Shield
        let shieldCharges = 1;
        let shieldActive = false;
        let shieldEndsAt = null;
        let shieldMesh = null;
        // Lift skill
        let liftCharges = 1;
        let liftRechargeTimer = 0;
        const liftInterval = 20;
        const liftMaxCharges = 2;
        let liftPrimed = false;
        let liftGrabActive = false; // true while ally is grabbing/aiming/throwing hero
        let liftAimDirection = 'east';
        let liftAimLine = null;
        let liftThrowAnim = null;
        let liftAttractAnim = null;
        let liftAnchorCell = null;
        let heroPadIndex = null;
        let allyPadIndex = null;
        let heroPrevButtons = [];
        let allyPrevButtons = [];
        let lastHeroDir = 'north';
        let lastAllyDir = 'north';
        const GAMEPAD_DEADZONE = 0.22;
        const PAD_JUMP_WINDOW = 0.55;
        let heroPadJumpPrimed = false;
        let allyPadJumpPrimed = false;
        let heroPadJumpTimer = 0;
        let allyPadJumpTimer = 0;
        let heroPadFreezePrimed = false;
        let heroPadFreezeTimer = 0;
        let heroPadExpandPrimed = false;
        let heroPadExpandTimer = 0;
        let allyPadFreezePrimed = false;
        let allyPadFreezeTimer = 0;
        let allyPadExpandPrimed = false;
        let allyPadExpandTimer = 0;
        // UI focus for gamepad
        let uiFocusItems = [];
        let uiFocusIndex = 0;
        let uiPrevVert = 0;
        let uiLoopHandle = null;
        // decision marker rotation (multiple active glows)
        const decisionActiveCount = 8;
        const decisionMinInterval = 10000;
        const decisionMaxInterval = 20000;
        let decisionActiveMap = new Map(); // key -> nextSwitchMs
        let decisionPool = [];
        let lastSyncedActive = "";

        const hudContainer = document.getElementById('hud');
        if (hudContainer) {
            hudContainer.innerHTML = `
        <div class="hud-card info-card">
            <h2>Info</h2>
            <div class="row"><span>Age</span><strong id="hud-age">--</strong></div>
            <div class="row"><span>Goal Age</span><strong id="hud-goal">--</strong></div>
            <div class="row"><span>Health</span><strong id="hud-health">100%</strong></div>
            <div class="row"><span class="trait empathy">Empathy</span><strong id="hud-empathy">--</strong></div>
            <div class="row"><span class="trait integrity">Integrity</span><strong id="hud-integrity">--</strong></div>
            <div class="row"><span class="trait courage">Courage</span><strong id="hud-courage">--</strong></div>
            <div class="row"><span class="trait responsibility">Responsibility</span><strong id="hud-resp">--</strong></div>
            <div class="row"><span class="trait independence">Independence</span><strong id="hud-ind">--</strong></div>
            <div class="row"><span>AI</span><strong id="hud-provider">--</strong></div>
        </div>
                <div class="hud-card hero-card">
                    <h2>🟡 Hero</h2>
                    <div class="row"><span>Jumps (A)</span><strong id="hud-hero-jumps">--</strong></div>
                    <div class="row"><span>Shield (X)</span><strong id="hud-shield">--</strong></div>
                    <div class="row"><span>Escape (B)</span><strong id="hud-escape">--</strong></div>
                </div>
                <div class="hud-card buddy-card">
                    <h2>🔵 Buddy</h2>
                    <div class="row"><span>Jumps (A)</span><strong id="hud-ally-jumps">--</strong></div>
                    <div class="row"><span>Freeze (X)</span><strong id="hud-freeze">--</strong></div>
                    <div class="row"><span>Frontier (Y)</span><strong id="hud-expand">--</strong></div>
                    <div class="row"><span>Dissolve (RT)</span><strong id="hud-dissolve">--</strong></div>
                    <div class="row"><span>Lift (B)</span><strong id="hud-lift">--</strong></div>
                    <div class="row"><span>Trap (LT/LB)</span><strong id="hud-trap">--</strong></div>
                    <div class="row"><span>Blink (RB)</span><strong id="hud-blink">--</strong></div>
                </div>
            `;
        }
        const hudAge = document.getElementById('hud-age');
        const hudStage = document.getElementById('hud-stage');
        const hudGoal = document.getElementById('hud-goal');
        const hudGrowth = document.getElementById('hud-growth');
        const hudProvider = document.getElementById('hud-provider');
        const hudFreeze = document.getElementById('hud-freeze');
        const hudExpand = document.getElementById('hud-expand');
        const hudShield = document.getElementById('hud-shield');
        const hudDissolve = document.getElementById('hud-dissolve');
        const hudHeroJumps = document.getElementById('hud-hero-jumps');
        const hudAllyJumps = document.getElementById('hud-ally-jumps');
        const hudEmpathy = document.getElementById('hud-empathy');
        const hudIntegrity = document.getElementById('hud-integrity');
        const hudCourage = document.getElementById('hud-courage');
        const hudResp = document.getElementById('hud-resp');
        const hudInd = document.getElementById('hud-ind');
        const toastEl = document.getElementById('toast');
        const loadingMask = document.getElementById('loading-mask');
        const loadingText = document.getElementById('loading-text');

        const decisionModal = document.getElementById('decision-modal');
        const decisionQuestionBox = document.getElementById('decision-question');
        const decisionWaitBox = document.getElementById('decision-wait');
        const decisionReviewBox = document.getElementById('decision-review');
        const decisionIntro = document.getElementById('decision-intro');
        const decisionPrompt = document.getElementById('decision-prompt');
        const decisionOptions = document.getElementById('decision-options');
        const decisionSubmit = document.getElementById('decision-submit');
        const reviewContinue = document.getElementById('review-continue');
        const reviewGrowth = document.getElementById('review-growth');
        const reviewScore = document.getElementById('review-score');
        const reviewFeedback = document.getElementById('review-feedback');
        const reviewValues = document.getElementById('review-values');
        const labelParents = document.getElementById('label-parents');
        const voiceParents = document.getElementById('voice-parents');
        const voiceFriend = document.getElementById('voice-friend');
        const labelFuture = document.getElementById('label-future');
        const voiceFuture = document.getElementById('voice-future');
        const waitTitle = document.getElementById('wait-title');
        const waitLabel = document.getElementById('wait-label');
        const waitEn = document.getElementById('wait-en');
        const waitCn = document.getElementById('wait-cn');
        const waitActions = document.getElementById('wait-actions');
        const waitView = document.getElementById('wait-view');

        const timelineModal = document.getElementById('timeline-modal');
        const timelineSummary = document.getElementById('timeline-summary');
        const timelineNarrative = document.getElementById('timeline-narrative');
        const timelineList = document.getElementById('timeline-list');
        const timelineGrowth = document.createElement('div');
        timelineGrowth.id = 'timeline-growth';
        const timelineScroll = document.getElementById('timeline-scroll');
        const timelineRestart = document.getElementById('timeline-restart');
        const startChoiceModal = document.getElementById('start-choice');
        const introModal = document.getElementById('intro-modal');
        const introStartBtn = document.getElementById('intro-start');
        const startContinueBtn = document.getElementById('start-continue');
        const startRestartBtn = document.getElementById('start-restart');
        const hudLift = document.getElementById('hud-lift');
        const hudTrap = document.getElementById('hud-trap');
        const hudBlink = document.getElementById('hud-blink');
        const hudHealth = document.getElementById('hud-health');
        const hudEscapeVal = document.getElementById('hud-escape');

        let selectedOption = null;
        let startChoiceHandled = false;
        let introHandled = false;
        let pendingStartMode = null;
        let trapSyncInterval = null;

        async function boot() {
            showLoading("Connecting to Moral Maze...");
            try {
                stateData = await fetchJson('/api/state');
                jumpCharges = stateData.jump_charges || 0;
                allyJumpCharges = stateData.ally_state?.jump_charges ?? 2;
                allyJumpTimer = 0;
                heroHealth = stateData.hero_health ?? heroHealth;
                if (hudHealth) hudHealth.textContent = `${heroHealth}%`;
                if (!stateData.ally_state) {
                    stateData.ally_state = {};
                }
                if (!stateData.ally_state.freeze) {
                    stateData.ally_state.freeze = null;
                }
                if (!stateData.ally_state.expand) {
                    stateData.ally_state.expand = null;
                }
                if (!stateData.ally_state.trap) {
                    stateData.ally_state.trap = { charges: trapCharges, traps: [] };
                } else {
                    trapCharges = stateData.ally_state.trap.charges ?? trapCharges;
                    if (stateData.ally_state.trap.traps) {
                        refreshTrapVisuals(stateData.ally_state.trap.traps);
                    }
                }
                if (stateData.ally_state.freeze) {
                    syncFreezeState(stateData.ally_state.freeze);
                }
                if (stateData.ally_state.expand) {
                    syncExpandState(stateData.ally_state.expand);
                }
                if (stateData.has_progress) {
                    pendingStartMode = 'choice';
                } else {
                    pendingStartMode = 'new';
                }
                hideLoading();
                if (introHandled) {
                    proceedAfterIntro();
                } else {
                    introModal.classList.remove('hidden');
                    buildUiFocusList();
                    startUiLoop();
                }
            } catch (err) {
                showLoading("Load failed: " + err.message);
            }
        }

        async function startWithExistingState() {
            showLoading("Loading maze...");
            try {
                mazeData = await fetchJson('/api/maze');
                jumpCharges = stateData.jump_charges || 0;
                updateJumpsHud();
                allyJumpCharges = stateData.ally_state?.jump_charges ?? allyJumpCharges;
                allyJumpTimer = 0;
                if (mazeData.traps) {
                    stateData.ally_state = stateData.ally_state || {};
                    stateData.ally_state.trap = stateData.ally_state.trap || {};
                    stateData.ally_state.trap.traps = mazeData.traps;
                    refreshTrapVisuals(mazeData.traps);
                }
                initializeGame();
            } catch (err) {
                showLoading("Load failed: " + err.message);
                if (stateData?.has_progress) {
                    startChoiceHandled = false;
                    startChoiceModal.classList.remove('hidden');
                    buildUiFocusList();
                    startUiLoop();
                }
            }
        }

        async function restartFromServer() {
            showLoading("Rebuilding maze...");
            try {
                const payload = await fetchJson('/api/state/restart', { method: 'POST' });
                stateData = payload.state;
                jumpCharges = stateData.jump_charges || 0;
                allyJumpCharges = stateData.ally_state?.jump_charges ?? allyJumpCharges;
                allyJumpTimer = 0;
                updateJumpsHud();
                mazeData = payload.maze;
                if (mazeData.traps) {
                    stateData.ally_state = stateData.ally_state || {};
                    stateData.ally_state.trap = stateData.ally_state.trap || {};
                    stateData.ally_state.trap.traps = mazeData.traps;
                    refreshTrapVisuals(mazeData.traps);
                }
                initializeGame();
            } catch (err) {
                startChoiceHandled = false;
                startChoiceModal.classList.remove('hidden');
                showToast("Restart failed: " + err.message);
                hideLoading();
            }
        }

        function initializeGame() {
            initializeCellGrid();
            updateWallGridFromCells();
            startChoiceModal.classList.add('hidden');
            startChoiceHandled = true;
            currentCell = { ...stateData.current_position };
            serverCell = { ...stateData.current_position };
            heroFrozen = false;
            if (freezeOverlay) {
                freezeOverlay.visible = false;
            }
            liftGrabActive = false;
            liftPrimed = false;
            clearLiftVisuals();
            setupWorld();
            if (stateData?.ally_state?.trap?.traps) {
                refreshTrapVisuals(stateData.ally_state.trap.traps);
            }
            updateHud(stateData);
            hideLoading();
            gamePhase = 'play';
            stopUiLoop();
            initDecisionRotation();
            requestAnimationFrame(gameLoop);
            if (!trapSyncInterval) {
                trapSyncInterval = setInterval(() => {
                    resyncTrapStateFromServer();
                }, 8000);
            }
        }

        function proceedAfterIntro() {
            if (pendingStartMode === 'choice') {
                startChoiceHandled = false;
                startChoiceModal.classList.remove('hidden');
                buildUiFocusList();
                startUiLoop();
            } else {
                stopUiLoop();
                startWithExistingState();
            }
        }

        introStartBtn.addEventListener('click', () => {
            introHandled = true;
            introModal.classList.add('hidden');
            proceedAfterIntro();
        });

        function setupWorld() {
            createPhysicsWorld();
            createRenderWorld();
            createDecisionMarkers();
            window.addEventListener('resize', onResize);
            KeyboardJS.bind.axis('left', 'right', 'down', 'up', onMoveKey);
            KeyboardJS.bind.axis('a', 'd', 's', 'w', onAllyMoveKey);
            window.addEventListener('keydown', handleJumpKeyDown);
            window.addEventListener('keyup', handleJumpKeyUp);
            window.addEventListener('keydown', handleFreezeKeyDown);
            window.addEventListener('keyup', handleFreezeKeyUp);
            window.addEventListener('keydown', handleExpandKeyDown);
            window.addEventListener('keyup', handleExpandKeyUp);
        }

        function createPhysicsWorld() {
            wWorld = new b2World(new b2Vec2(0, 0), true);

            const startTile = cellToTile(stateData.current_position.x, stateData.current_position.y);

            const bodyDef = new b2BodyDef();
            bodyDef.type = b2Body.b2_dynamicBody;
            bodyDef.position.Set(startTile.x, startTile.y);
            wBall = wWorld.CreateBody(bodyDef);
            const fixDef = new b2FixtureDef();
            fixDef.density = 1.0;
            fixDef.friction = 0.0;
            fixDef.restitution = 0.25;
            fixDef.shape = new b2CircleShape(ballRadius);
            heroBaseDensity = fixDef.density;
            heroFixture = wBall.CreateFixture(fixDef);
            heroMassScale = 1;

            buildWallBodies();
            createAllyBody();
        }

        function createAllyBody() {
            if (!wWorld) return;
            const bodyDef = new b2BodyDef();
            bodyDef.type = b2Body.b2_dynamicBody;
            const spawnTile = cellToTile(
                Math.min(mazeData.width - 1, stateData.current_position.x + 1),
                stateData.current_position.y
            );
            bodyDef.position.Set(spawnTile.x, spawnTile.y);
            allyBody = wWorld.CreateBody(bodyDef);
            const fixDef = new b2FixtureDef();
            fixDef.density = 0.6;
            fixDef.friction = 0.1;
            fixDef.restitution = 0.45;
            fixDef.shape = new b2CircleShape(ballRadius * 0.9);
            allyBody.CreateFixture(fixDef);
        }

        function buildWallBodies() {
            wallBodies.clear();
            if (!mazeData || !wWorld) return;
            const width = mazeData.grid_size.width;
            const height = mazeData.grid_size.height;
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    if (mazeData.wall_grid[x][y]) {
                        const body = createWallBody(x, y);
                        if (body) {
                            wallBodies.set(wallKey(x, y), body);
                        }
                    }
                }
            }
        }

        function refreshWallMeshes() {
            if (!mazeMesh || !mazeData?.wall_grid) return;
            for (const mesh of wallMeshes.values()) {
                mazeMesh.remove(mesh);
            }
            wallMeshes.clear();

            const width = mazeData.grid_size.width;
            const height = mazeData.grid_size.height;
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    if (mazeData.wall_grid[x][y]) {
                        const mesh = createWallMesh(x, y);
                        wallMeshes.set(wallKey(x, y), mesh);
                        mazeMesh.add(mesh);
                    }
                }
            }
        }

        function rebuildAllWalls() {
            wallBodies.forEach(body => wWorld.DestroyBody(body));
            wallBodies.clear();
            buildWallBodies();
            refreshWallMeshes();
        }

        function createRenderWorld() {
            scene = new THREE.Scene();

            light = new THREE.PointLight(0xffffff, 1);
            const startTile = cellToTile(stateData.current_position.x, stateData.current_position.y);
            light.position.set(startTile.x, startTile.y, 3);
            scene.add(light);

            const g = new THREE.SphereGeometry(ballRadius, 32, 16);
            const m = new THREE.MeshPhongMaterial({ map: ironTexture });
            ballMesh = new THREE.Mesh(g, m);
            ballMesh.position.set(startTile.x, startTile.y, ballRadius);
            scene.add(ballMesh);
            const freezeGeo = new THREE.SphereGeometry(ballRadius * 1.3, 32, 32);
            const freezeMat = new THREE.MeshPhongMaterial({
                color: 0x66ccff,
                transparent: true,
                opacity: 0.35,
                emissive: 0x88ccff,
                emissiveIntensity: 0.5,
            });
            freezeOverlay = new THREE.Mesh(freezeGeo, freezeMat);
            freezeOverlay.visible = false;
            scene.add(freezeOverlay);
            const BeamGeometry = THREE.BoxGeometry || THREE.CubeGeometry;
            const freezeBeamGeo = new BeamGeometry(1, 0.3, 0.3);
            const freezeBeamMat = new THREE.MeshBasicMaterial({ color: 0xff3355, transparent: true, opacity: 0.75 });
            freezeBeam = new THREE.Mesh(freezeBeamGeo, freezeBeamMat);
            freezeBeam.visible = false;
            scene.add(freezeBeam);
            const allyGeo = new THREE.SphereGeometry(ballRadius * 0.9, 32, 16);
            const allyMat = new THREE.MeshPhongMaterial({
                color: 0x3f51b5,
                transparent: true,
                opacity: 0.65,
                shininess: 80,
            });
            const allyStart = cellToTile(
                Math.min(mazeData.width - 1, stateData.current_position.x + 1),
                stateData.current_position.y
            );
            allyMesh = new THREE.Mesh(allyGeo, allyMat);
            allyMesh.position.set(allyStart.x, allyStart.y, ballRadius);
            scene.add(allyMesh);
            // red glow halo for ally
            const glowGeo = new THREE.SphereGeometry(ballRadius * 1.1, 24, 16);
            const glowMat = new THREE.MeshPhongMaterial({
                color: 0xff3355,
                emissive: 0xff2244,
                emissiveIntensity: 2.4,
                transparent: true,
                opacity: 0.55,
                depthWrite: false,
            });
            allyGlow = new THREE.Mesh(glowGeo, glowMat);
            allyGlow.position.set(allyStart.x, allyStart.y, ballRadius);
            scene.add(allyGlow);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 2000);
            camera.position.set(startTile.x + 5, startTile.y - 6, 18);
            camera.lookAt(new THREE.Vector3(startTile.x, startTile.y, 0));
            scene.add(camera);

            mazeMesh = new THREE.Object3D();
            scene.add(mazeMesh);
            refreshWallMeshes();

            const planeWidth = mazeData.grid_size.width;
            const planeHeight = mazeData.grid_size.height;
            const planeGeo = new THREE.PlaneGeometry(planeWidth * 1.1, planeHeight * 1.1, 1, 1);
            planeTexture.wrapS = planeTexture.wrapT = THREE.RepeatWrapping;
            planeTexture.repeat.set(planeWidth / 2, planeHeight / 2);
            const planeMat = new THREE.MeshPhongMaterial({ map: planeTexture });
            planeMesh = new THREE.Mesh(planeGeo, planeMat);
            planeMesh.position.set((planeWidth - 1) / 2, (planeHeight - 1) / 2, 0);
            planeMesh.rotation.set(Math.PI / 2, 0, 0);
            scene.add(planeMesh);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
        }

        function buildCircleGeometry(radius, segments) {
            const geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(0, 0, 0));
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                geometry.vertices.push(new THREE.Vector3(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    0
                ));
            }
            for (let i = 1; i <= segments; i++) {
                geometry.faces.push(new THREE.Face3(0, i, i + 1));
            }
            geometry.computeFaceNormals();
            geometry.computeVertexNormals();
            return geometry;
        }

        function createDecisionMarkers() {
            const geometry = buildCircleGeometry(0.35, 32);
            const ensureMarker = (x, y, visited = false) => {
                const key = `${x},${y}`;
                if (decisionMarkers.has(key)) return;
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffd56b,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide,
                });
                const marker = new THREE.Mesh(geometry, material);
                const tile = cellToTile(x, y);
                marker.rotation.x = Math.PI / 2;
                marker.position.set(tile.x, tile.y, 0.05);
                marker.visible = !visited;
                scene.add(marker);
                decisionMarkers.set(key, marker);
            };
            (mazeData.decision_nodes || []).forEach(node => {
                ensureMarker(node.x, node.y, node.visited);
            });
            (mazeData.active_decisions || []).forEach(pos => {
                ensureMarker(pos.x, pos.y, false);
            });
            initDecisionRotation();
        }

        function wallKey(x, y) {
            return `${x},${y}`;
        }

        function createWallBody(x, y) {
            if (!wWorld) return null;
            const bodyDef = new b2BodyDef();
            bodyDef.type = b2Body.b2_staticBody;
            bodyDef.position.Set(x, y);
            const fixDef = new b2FixtureDef();
            fixDef.density = 1.0;
            fixDef.friction = 0.0;
            fixDef.restitution = 0.0;
            fixDef.shape = new b2PolygonShape();
            fixDef.shape.SetAsBox(0.5, 0.5);
            const body = wWorld.CreateBody(bodyDef);
            body.CreateFixture(fixDef);
            return body;
        }

        function createWallMesh(x, y) {
            const material = (typeof wallMaterial?.clone === 'function')
                ? wallMaterial.clone()
                : new THREE.MeshPhongMaterial({ map: brickTexture });
            material.map = material.map || brickTexture;
            material.color = material.color || new THREE.Color(0xffffff);
            material.emissive = material.emissive || new THREE.Color(0x000000);
            material.needsUpdate = true;

            const mesh = new THREE.Mesh(wallGeometry, material);
            mesh.position.set(x, y, 0.5);
            mesh.userData = mesh.userData || {};
            mesh.userData.baseColor = material.color.clone();
            mesh.userData.baseEmissive = material.emissive.clone();
            mesh.userData.baseEmissiveIntensity = typeof material.emissiveIntensity === 'number' ? material.emissiveIntensity : 1.0;
            mesh.userData.baseMap = material.map || brickTexture;
            mesh.userData.baseMaterial = material;
            mesh.userData.highlightMaterial = null;
            return mesh;
        }

        function addWallAt(x, y) {
            const key = wallKey(x, y);
            if (!wallBodies.has(key)) {
                const body = createWallBody(x, y);
                if (body) {
                    wallBodies.set(key, body);
                }
            }
            if (!wallMeshes.has(key) && mazeMesh) {
                const mesh = createWallMesh(x, y);
                wallMeshes.set(key, mesh);
                mazeMesh.add(mesh);
                highlightWall(key, additionHighlightColor, additionHighlightDuration);
            }
        }

        function removeWallAt(x, y) {
            const key = wallKey(x, y);
            const body = wallBodies.get(key);
            if (body && wWorld) {
                wWorld.DestroyBody(body);
            }
            wallBodies.delete(key);
            const mesh = wallMeshes.get(key);
            if (mesh && mazeMesh) {
                mazeMesh.remove(mesh);
            }
            wallMeshes.delete(key);
            wallHighlightStates.delete(key);
        }

        function highlightWall(key, colorHex, durationSeconds) {
            const mesh = wallMeshes.get(key);
            if (!mesh) return;
            if (!mesh.material) return;
            mesh.userData = mesh.userData || {};
            if (!mesh.userData.highlightMaterial) {
                mesh.userData.highlightMaterial = new THREE.MeshBasicMaterial({ color: colorHex });
            } else if (mesh.userData.highlightMaterial.color && typeof mesh.userData.highlightMaterial.color.set === 'function') {
                mesh.userData.highlightMaterial.color.set(colorHex);
            }
            mesh.material = mesh.userData.highlightMaterial;
            mesh.material.needsUpdate = true;
            const expires = performance.now() + durationSeconds * 1000;
            wallHighlightStates.set(key, { expires });
        }

        function resetWallMeshColor(mesh) {
            if (!mesh?.material) return;
            const baseMaterial = mesh.userData?.baseMaterial || mesh.material;
            if (mesh.userData?.baseColor && baseMaterial.color && typeof baseMaterial.color.copy === 'function') {
                baseMaterial.color.copy(mesh.userData.baseColor);
            } else if (baseMaterial.color && typeof baseMaterial.color.set === 'function') {
                baseMaterial.color.set(0xffffff);
            }
            if (baseMaterial.emissive) {
                if (mesh.userData?.baseEmissive && typeof baseMaterial.emissive.copy === 'function') {
                    baseMaterial.emissive.copy(mesh.userData.baseEmissive);
                } else if (typeof baseMaterial.emissive.set === 'function') {
                    baseMaterial.emissive.set(0x000000);
                }
            }
            baseMaterial.emissiveIntensity = mesh.userData?.baseEmissiveIntensity ?? 1.0;
            mesh.material = baseMaterial;
            mesh.material.needsUpdate = true;
        }

        function updateWallHighlights(nowMs) {
            for (const [key, state] of wallHighlightStates.entries()) {
                if (nowMs >= state.expires) {
                    wallHighlightStates.delete(key);
                    const mesh = wallMeshes.get(key);
                    if (mesh) {
                        resetWallMeshColor(mesh);
                    }
                }
            }
        }

        function enqueueWallMutations(batch) {
            if (!batch || !batch.length) return;
            pendingWallMutations.push(...batch);
            if (!mutationSyncPromise) {
                mutationSyncPromise = flushWallMutations();
            }
        }

        async function flushWallMutations() {
            while (pendingWallMutations.length) {
                const batch = pendingWallMutations.splice(0, pendingWallMutations.length);
                try {
                    await fetchJson('/api/maze/mutations', {
                        method: 'POST',
                        body: JSON.stringify({ operations: batch }),
                    });
                } catch (err) {
                    console.warn('Maze morph sync failed', err);
                    pendingWallMutations.unshift(...batch);
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }
            mutationSyncPromise = null;
        }

        function initializeCellGrid() {
            if (!mazeData?.cells) {
                cellGrid = null;
                return;
            }
            const width = mazeData.width;
            const height = mazeData.height;
            cellGrid = Array.from({ length: height }, () => new Array(width));
            for (const cell of mazeData.cells) {
                cellGrid[cell.y][cell.x] = {
                    ...cell,
                    walls: { ...cell.walls },
                };
            }
        }

        function updateWallGridFromCells(options = {}) {
            if (!cellGrid || !mazeData) return;
            const width = mazeData.width;
            const height = mazeData.height;
            const gridW = width * 2 + 1;
            const gridH = height * 2 + 1;
            const newGrid = Array.from({ length: gridW }, () => Array(gridH).fill(true));

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const cell = cellGrid[y][x];
                    if (!cell) continue;
                    const px = 2 * x + 1;
                    const py = 2 * y + 1;
                    newGrid[px][py] = false;
                    if (!cell.walls.north && py - 1 >= 0) newGrid[px][py - 1] = false;
                    if (!cell.walls.south && py + 1 < gridH) newGrid[px][py + 1] = false;
                    if (!cell.walls.west && px - 1 >= 0) newGrid[px - 1][py] = false;
                    if (!cell.walls.east && px + 1 < gridW) newGrid[px + 1][py] = false;
                }
            }

            if (options.applyDiff && mazeData.wall_grid) {
                applyWallGridDiff(newGrid);
            } else {
                mazeData.wall_grid = newGrid;
                mazeData.grid_size = {
                    width: gridW,
                    height: gridH,
                };
            }
            return newGrid;
        }

        function applyWallGridDiff(newGrid) {
            const nextWidth = newGrid.length;
            const nextHeight = newGrid[0]?.length || 0;
            const currentGrid = mazeData.wall_grid || [];
            for (let x = 0; x < nextWidth; x++) {
                if (!newGrid[x]) continue;
                for (let y = 0; y < nextHeight; y++) {
                    const prev = currentGrid?.[x]?.[y];
                    const next = newGrid[x][y];
                    if (prev === next) continue;
                    if (next) {
                        addWallAt(x, y);
                    } else {
                        removeWallAt(x, y);
                    }
                }
            }
            mazeData.wall_grid = newGrid;
            mazeData.grid_size = {
                width: nextWidth,
                height: nextHeight,
            };
        }

        function getNeighborCell(x, y, dirKey) {
            const dir = CELL_DIRS[dirKey];
            if (!dir) return null;
            const nx = x + dir.dx;
            const ny = y + dir.dy;
            if (!cellGrid?.[ny]?.[nx]) return null;
            return { x: nx, y: ny, cell: cellGrid[ny][nx], dir };
        }

        function openWallBetween(x, y, dirKey) {
            const current = cellGrid?.[y]?.[x];
            const neighbor = getNeighborCell(x, y, dirKey);
            if (!current) return false;
            if (!current.walls[dirKey]) return false;
            current.walls[dirKey] = false;
            if (neighbor?.cell) {
                neighbor.cell.walls[neighbor.dir.opposite] = false;
            }
            return true;
        }

        function closeWallBetween(x, y, dirKey) {
            const current = cellGrid?.[y]?.[x];
            const neighbor = getNeighborCell(x, y, dirKey);
            if (!current) return false;
            if (current.walls[dirKey]) return false;
            current.walls[dirKey] = true;
            if (neighbor?.cell) {
                neighbor.cell.walls[neighbor.dir.opposite] = true;
            }
            return true;
        }

        function getWallTileCoords(x, y, dirKey) {
            const px = 2 * x + 1;
            const py = 2 * y + 1;
            switch (dirKey) {
                case 'north':
                    return { gridX: px, gridY: py - 1 };
                case 'south':
                    return { gridX: px, gridY: py + 1 };
                case 'west':
                    return { gridX: px - 1, gridY: py };
                case 'east':
                    return { gridX: px + 1, gridY: py };
                default:
                    return null;
            }
        }

        function scheduleWallOpening(x, y, dirKey) {
            const current = cellGrid?.[y]?.[x];
            if (!current || !current.walls[dirKey]) return false;
            const alreadyScheduled = scheduledWallMutations.some(task => task.action === 'open' && task.x === x && task.y === y && task.dirKey === dirKey);
            if (alreadyScheduled) return false;
            const tile = getWallTileCoords(x, y, dirKey);
            if (tile) {
                highlightWall(wallKey(tile.gridX, tile.gridY), removalHighlightColor, removalWarningDuration);
            }
            scheduledWallMutations.push({
                action: 'open',
                x,
                y,
                dirKey,
                executeAt: performance.now() + removalWarningDuration * 1000,
            });
            return true;
        }

        function processScheduledWallMutations(nowMs, mutationOps) {
            let changed = false;
            for (let i = scheduledWallMutations.length - 1; i >= 0; i--) {
                const task = scheduledWallMutations[i];
                if (nowMs < task.executeAt) continue;
                scheduledWallMutations.splice(i, 1);
                if (task.action === 'open') {
                    if (openWallBetween(task.x, task.y, task.dirKey)) {
                        mutationOps.push({ x: task.x, y: task.y, direction: task.dirKey, action: 'open' });
                        changed = true;
                    }
                }
            }
            return changed;
        }

        function getRandomCellForMutation(ballCellX, ballCellY) {
            if (!cellGrid) return null;
            const width = mazeData.width;
            const height = mazeData.height;
            for (let attempt = 0; attempt < 80; attempt++) {
                const x = Math.floor(Math.random() * width);
                const y = Math.floor(Math.random() * height);
                if (!cellGrid[y][x]) continue;
                if (Math.abs(x - ballCellX) <= 1 && Math.abs(y - ballCellY) <= 1) continue;
                if (x === 0 && y === 0) continue;
                return { x, y, cell: cellGrid[y][x] };
            }
            return null;
        }


        function animateMazeMesh(delta) {
            if (!wallMeshes.size) return;
            mazeWavePhase += delta;
            for (const mesh of wallMeshes.values()) {
                if (!mesh) continue;
                mesh.position.z = 0.5 + Math.sin(mazeWavePhase * 1.3 + mesh.position.x * 0.18 + mesh.position.y * 0.21) * 0.2;
            }
        }

        function isBallMoving() {
            if (isJumping) return true;
            if (!wBall) return false;
            const vel = wBall.GetLinearVelocity();
            return Math.abs(vel.x) > 0.05 || Math.abs(vel.y) > 0.05;
        }

        function mutateMaze(delta) {
            if (!mazeData || !cellGrid) return;
            const now = performance.now();
            const mutationOps = [];
            let changed = processScheduledWallMutations(now, mutationOps);

            const finalizeMutations = () => {
                if (changed) {
                    updateWallGridFromCells({ applyDiff: true });
                }
                if (mutationOps.length) {
                    enqueueWallMutations(mutationOps);
                }
            };

        mazeMutationTimer += delta;
        if (mazeMutationTimer < mutationInterval) {
            finalizeMutations();
            return;
        }
            mazeMutationTimer = 0;

            const ballGridX = Math.round(ballMesh.position.x);
            const ballGridY = Math.round(ballMesh.position.y);
            const ballCellX = Math.max(0, Math.min(mazeData.width - 1, Math.floor((ballGridX - 1) / 2)));
            const ballCellY = Math.max(0, Math.min(mazeData.height - 1, Math.floor((ballGridY - 1) / 2)));

            for (let i = 0; i < mutationsPerInterval; i++) {
                const picked = getRandomCellForMutation(ballCellX, ballCellY);
                if (!picked) break;
                const cell = picked.cell;
                const directions = Object.keys(CELL_DIRS);
                const closed = directions.filter(dir => cell.walls[dir]);
                const open = directions.filter(dir => !cell.walls[dir]);

                const shouldRelocate = Math.random() < relocationChance && closed.length && open.length;
                if (shouldRelocate) {
                    const dirToRemove = closed[Math.floor(Math.random() * closed.length)];
                    const dirToAdd = open[Math.floor(Math.random() * open.length)];
                    scheduleWallOpening(picked.x, picked.y, dirToRemove);
                    const closedNew = closeWallBetween(picked.x, picked.y, dirToAdd);
                    if (closedNew) {
                        mutationOps.push({ x: picked.x, y: picked.y, direction: dirToAdd, action: 'close' });
                        changed = true;
                    }
                } else if (Math.random() < removalChance && closed.length) {
                    const dirKey = closed[Math.floor(Math.random() * closed.length)];
                    scheduleWallOpening(picked.x, picked.y, dirKey);
                } else if (open.length) {
                    const dirKey = open[Math.floor(Math.random() * open.length)];
                    const closedNew = closeWallBetween(picked.x, picked.y, dirKey);
                    if (closedNew) {
                        mutationOps.push({ x: picked.x, y: picked.y, direction: dirKey, action: 'close' });
                        changed = true;
                    }
                }
            }

            finalizeMutations();
        }

        function initDecisionRotation() {
            decisionActiveMap.clear();
            decisionPool = [];
            const now = performance.now();
            const visitedSet = new Set(
                (mazeData.decision_nodes || [])
                    .filter(n => n.visited)
                    .map(n => `${n.x},${n.y}`)
            );
            const activeFromServer = (mazeData.active_decisions || []).map(pos => `${pos.x},${pos.y}`);
            // seed pool with all non-visited cells in grid
            const width = mazeData.width || (mazeData.grid_size?.width ? Math.floor((mazeData.grid_size.width - 1) / 2) : 0);
            const height = mazeData.height || (mazeData.grid_size?.height ? Math.floor((mazeData.grid_size.height - 1) / 2) : 0);
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    const key = `${x},${y}`;
                    if (visitedSet.has(key)) continue;
                    decisionPool.push(key);
                    const marker = decisionMarkers.get(key);
                    if (marker) marker.visible = false;
                }
            }
            // activate server-provided ones first
            activeFromServer.forEach(key => {
                decisionPool = decisionPool.filter(k => k !== key);
                activateDecisionKey(key, now);
            });
            refillDecisionActives(now);
        }

        function refillDecisionActives(nowMs = performance.now()) {
            while (decisionActiveMap.size < decisionActiveCount && decisionPool.length > 0) {
                const idx = Math.floor(Math.random() * decisionPool.length);
                const key = decisionPool.splice(idx, 1)[0];
                activateDecisionKey(key, nowMs);
            }
            scheduleActiveSync();
        }

        function randomIntervalMs() {
            return decisionMinInterval + Math.random() * (decisionMaxInterval - decisionMinInterval);
        }

        function activateDecisionKey(key, nowMs = performance.now()) {
            let marker = decisionMarkers.get(key);
            if (!marker) {
                const [cx, cy] = key.split(',').map(Number);
                const geometry = buildCircleGeometry(0.35, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffd56b,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide,
                });
                marker = new THREE.Mesh(geometry, material);
                const tile = cellToTile(cx, cy);
                marker.rotation.x = Math.PI / 2;
                marker.position.set(tile.x, tile.y, 0.05);
                scene.add(marker);
                decisionMarkers.set(key, marker);
            }
            if (marker) {
                marker.visible = true;
                const applyVisual = (mat) => {
                    if (!mat) return;
                    if (mat.color && typeof mat.color.set === 'function') {
                        mat.color.set(0xffd56b);
                    }
                    if (typeof mat.opacity === 'number') {
                        mat.opacity = 0.6;
                        mat.transparent = true;
                    }
                };
                if (Array.isArray(marker.material)) {
                    marker.material.forEach(applyVisual);
                } else {
                    applyVisual(marker.material);
                }
            }
            decisionActiveMap.set(key, nowMs + randomIntervalMs());
            scheduleActiveSync();
        }

        function deactivateDecisionKey(key) {
            const marker = decisionMarkers.get(key);
            if (marker) {
                marker.visible = false;
            }
            decisionActiveMap.delete(key);
            scheduleActiveSync();
        }

        function dissolveDecisionKey(key, restoreAtMs) {
            const marker = decisionMarkers.get(key);
            if (marker) marker.visible = false;
            decisionActiveMap.delete(key);
            decisionPool = decisionPool.filter(k => k !== key);
            dissolvedMap.set(key, restoreAtMs || performance.now() + dissolveInterval * 1000);
            refillDecisionActives();
            scheduleActiveSync();
        }

        function tickDecisionRotation(nowMs) {
            if (!mazeData || !decisionActiveMap.size) return;
            const entries = Array.from(decisionActiveMap.entries());
            let changed = false;
            for (const [key, nextMs] of entries) {
                if (nowMs < nextMs) continue;
                // Always move current key to pool so it can rotate back later
                deactivateDecisionKey(key);
                decisionPool.push(key);
                // If pool empty after push, just reactivate same key
                const idx = Math.floor(Math.random() * decisionPool.length);
                const newKey = decisionPool.splice(idx, 1)[0];
                activateDecisionKey(newKey, nowMs);
                changed = true;
            }
            refillDecisionActives(nowMs);
            if (changed) scheduleActiveSync();
        }

        let activeSyncTimer = null;
        function scheduleActiveSync() {
            if (activeSyncTimer) return;
            activeSyncTimer = setTimeout(syncActiveDecisionKeys, 150);
        }

        async function syncActiveDecisionKeys() {
            clearTimeout(activeSyncTimer);
            activeSyncTimer = null;
            const activeList = Array.from(decisionActiveMap.keys()).map(key => {
                const [x, y] = key.split(',').map(Number);
                return { x, y };
            });
            const keyStr = JSON.stringify(activeList);
            if (keyStr === lastSyncedActive) return;
            lastSyncedActive = keyStr;
            try {
                await fetchJson('/api/decisions/active', {
                    method: 'POST',
                    body: JSON.stringify({ active: activeList }),
                });
            } catch (err) {
                console.warn('sync active decisions failed', err);
            }
        }

        function processGamepadInput() {
            const pads = navigator.getGamepads ? navigator.getGamepads() : null;
            if (!pads) return;
            const nowDelta = (performance.now() - lastFrameTime) / 1000;
            if (heroPadJumpPrimed) heroPadJumpTimer += nowDelta;
            if (allyPadJumpPrimed) allyPadJumpTimer += nowDelta;
            if (heroPadFreezePrimed) heroPadFreezeTimer += nowDelta;
            if (heroPadExpandPrimed) heroPadExpandTimer += nowDelta;
            if (allyPadFreezePrimed) allyPadFreezeTimer += nowDelta;
            if (allyPadExpandPrimed) allyPadExpandTimer += nowDelta;
            if (heroPadJumpPrimed && heroPadJumpTimer > PAD_JUMP_WINDOW) {
                heroPadJumpPrimed = false;
                heroPadJumpTimer = 0;
            }
            if (allyPadJumpPrimed && allyPadJumpTimer > PAD_JUMP_WINDOW) {
                allyPadJumpPrimed = false;
                allyPadJumpTimer = 0;
            }
            if (heroPadFreezePrimed && heroPadFreezeTimer > PAD_JUMP_WINDOW) {
                heroPadFreezePrimed = false;
                heroPadFreezeTimer = 0;
            }
            if (heroPadExpandPrimed && heroPadExpandTimer > PAD_JUMP_WINDOW) {
                heroPadExpandPrimed = false;
                heroPadExpandTimer = 0;
            }
            if (allyPadFreezePrimed && allyPadFreezeTimer > PAD_JUMP_WINDOW) {
                allyPadFreezePrimed = false;
                allyPadFreezeTimer = 0;
            }
            if (allyPadExpandPrimed && allyPadExpandTimer > PAD_JUMP_WINDOW) {
                allyPadExpandPrimed = false;
                allyPadExpandTimer = 0;
            }
            if (heroPadIndex === null) {
                for (let i = 0; i < pads.length; i++) {
                    if (pads[i]) {
                        heroPadIndex = i;
                        heroPrevButtons = pads[i].buttons.map(b => b.pressed);
                        break;
                    }
                }
            }
            if (allyPadIndex === null) {
                for (let i = 0; i < pads.length; i++) {
                    if (i === heroPadIndex) continue;
                    if (pads[i]) {
                        allyPadIndex = i;
                        allyPrevButtons = pads[i].buttons.map(b => b.pressed);
                        break;
                    }
                }
            }
            const uiBlocking = isUiBlocking();
            if (uiBlocking && heroPadIndex !== null && pads[heroPadIndex]) {
                applyPadToUi(pads[heroPadIndex]);
                return;
            }
            if (heroPadIndex !== null && pads[heroPadIndex]) {
                applyPadToHero(pads[heroPadIndex]);
            }
            // 防止英雄跳跃瞬间误触发同方向的同伴跳跃：跳跃进行中或待处理时跳过同伴按键
            if (!pendingJump && !isJumping && allyPadIndex !== null && pads[allyPadIndex]) {
                applyPadToAlly(pads[allyPadIndex]);
            }
        }

        function startUiLoop() {
            if (uiLoopHandle !== null) return;
            const step = () => {
                processGamepadInput();
                uiLoopHandle = requestAnimationFrame(step);
            };
            step();
        }

        function stopUiLoop() {
            if (uiLoopHandle !== null) {
                cancelAnimationFrame(uiLoopHandle);
                uiLoopHandle = null;
            }
        }

        function dominantDir(x, y) {
            if (Math.abs(x) < GAMEPAD_DEADZONE && Math.abs(y) < GAMEPAD_DEADZONE) return null;
            if (Math.abs(x) > Math.abs(y)) {
                return x > 0 ? 'east' : 'west';
            }
            return y > 0 ? 'south' : 'north';
        }

        function readPadAxes(pad) {
            let x = pad.axes[0] || 0;
            let yRaw = pad.axes[1] || 0;
            const up = pad.buttons[12]?.pressed;
            const down = pad.buttons[13]?.pressed;
            const left = pad.buttons[14]?.pressed;
            const right = pad.buttons[15]?.pressed;
            if (up || down || left || right) {
                x = (left ? -1 : 0) + (right ? 1 : 0);
                yRaw = (up ? -1 : 0) + (down ? 1 : 0);
            }
            // Flip Y so pushing up moves character up
            const y = -yRaw;
            const dir = dominantDir(x, y);
            const nx = Math.abs(x) < GAMEPAD_DEADZONE ? 0 : x;
            const ny = Math.abs(y) < GAMEPAD_DEADZONE ? 0 : y;
            return { x: nx, y: ny, dir };
        }

        function edgePressed(pad, prev, idx) {
            const pressed = !!pad.buttons[idx]?.pressed;
            const was = prev[idx] || false;
            prev[idx] = pressed;
            return pressed && !was;
        }

        function applyPadToHero(pad) {
            const { x, y, dir } = readPadAxes(pad);
            if (liftGrabActive) {
                // In lift state only allow escape by the hero player; other inputs are ignored.
                if (edgePressed(pad, heroPrevButtons, 1)) { // B -> escape
                    attemptEscape();
                }
                return;
            }
            if (dir) lastHeroDir = dir;
            keyAxis = [x, y];
            if (heroPadJumpPrimed && dir) {
                heroPadJumpPrimed = false;
                heroPadJumpTimer = 0;
                attemptJump(dir);
            } else if (edgePressed(pad, heroPrevButtons, 0)) {
                if (dir) {
                    attemptJump(dir);
                } else {
                    heroPadJumpPrimed = true;
                    heroPadJumpTimer = 0;
                }
            }
            if (edgePressed(pad, heroPrevButtons, 1)) { // B -> escape
                attemptEscape();
            }
            if (edgePressed(pad, heroPrevButtons, 2)) { // X -> shield
                attemptShield();
            }
            if (heroPadExpandPrimed && dir) {
                heroPadExpandPrimed = false;
                heroPadExpandTimer = 0;
                attemptExpand(dir);
            } else if (edgePressed(pad, heroPrevButtons, 3)) {
                if (dir) {
                    attemptExpand(dir);
                } else {
                    heroPadExpandPrimed = true;
                    heroPadExpandTimer = 0;
                }
            }
        }

        function applyPadToAlly(pad) {
            const { x, y, dir } = readPadAxes(pad);
            if (liftGrabActive) {
                if (dir) {
                    liftAimDirection = dir;
                    updateLiftAimVisual();
                }
                if (edgePressed(pad, allyPrevButtons, 0)) {
                    confirmLiftThrow();
                } else if (edgePressed(pad, allyPrevButtons, 1)) {
                    confirmLiftRoll();
                }
                return;
            }
            if (dir) lastAllyDir = dir;
            allyAxis = [x, y];
            if (allyPadJumpPrimed && dir) {
                allyPadJumpPrimed = false;
                allyPadJumpTimer = 0;
                attemptAllyJump(dir);
            } else if (edgePressed(pad, allyPrevButtons, 0)) {
                if (dir) {
                    attemptAllyJump(dir);
                } else {
                    allyPadJumpPrimed = true;
                    allyPadJumpTimer = 0;
                }
            }
            if (allyPadFreezePrimed && dir) {
                allyPadFreezePrimed = false;
                allyPadFreezeTimer = 0;
                attemptFreeze(dir);
            } else if (edgePressed(pad, allyPrevButtons, 2)) {
                if (dir) {
                    attemptFreeze(dir);
                } else {
                    allyPadFreezePrimed = true;
                    allyPadFreezeTimer = 0;
                }
            }
            if (allyPadExpandPrimed && dir) {
                allyPadExpandPrimed = false;
                allyPadExpandTimer = 0;
                attemptExpand(dir);
            } else if (edgePressed(pad, allyPrevButtons, 3)) {
                if (dir) {
                    attemptExpand(dir);
                } else {
                    allyPadExpandPrimed = true;
                    allyPadExpandTimer = 0;
                }
            }
            if (edgePressed(pad, allyPrevButtons, 7)) { // RT
                attemptDissolve();
            }
            if (edgePressed(pad, allyPrevButtons, 6)) { // LT
                attemptTrap('mine');
            }
            if (edgePressed(pad, allyPrevButtons, 4)) { // LB
                attemptTrap('medkit');
            }
            if (edgePressed(pad, allyPrevButtons, 5)) { // RB
                attemptBlink();
            }
            if (edgePressed(pad, allyPrevButtons, 1)) { // B
                attemptLiftStart(dir || lastAllyDir || 'east');
            }
        }

        function isUiBlocking() {
            return !introModal.classList.contains('hidden')
                || !startChoiceModal.classList.contains('hidden')
                || !decisionModal.classList.contains('hidden')
                || !timelineModal.classList.contains('hidden');
        }

        function buildUiFocusList() {
            const items = [];
            if (!introModal.classList.contains('hidden')) {
                items.push(introStartBtn);
            } else if (!startChoiceModal.classList.contains('hidden')) {
                items.push(startContinueBtn, startRestartBtn);
            } else if (!decisionModal.classList.contains('hidden')) {
                const optionButtons = Array.from(decisionOptions.querySelectorAll('button'));
                if (decisionStatus === 'showing_review') {
                    items.push(reviewContinue);
                } else if (decisionStatus === 'waiting_review_ready') {
                    items.push(waitView);
                } else {
                    items.push(...optionButtons);
                    items.push(decisionSubmit);
                }
            } else if (!timelineModal.classList.contains('hidden')) {
                items.push(timelineRestart);
            }
            uiFocusItems = items.filter(Boolean);
            uiFocusIndex = Math.min(uiFocusIndex, Math.max(0, uiFocusItems.length - 1));
            applyUiFocus();
        }

        function clearUiFocus() {
            uiFocusItems.forEach(el => el.classList.remove('gp-focus'));
        }

        function applyUiFocus() {
            clearUiFocus();
            if (!uiFocusItems.length) return;
            const el = uiFocusItems[uiFocusIndex];
            el.classList.add('gp-focus');
            if (typeof el.scrollIntoView === 'function') {
                el.scrollIntoView({ block: 'nearest' });
            }
        }

        function moveUiFocus(delta) {
            if (!uiFocusItems.length) return;
            uiFocusIndex = (uiFocusIndex + delta + uiFocusItems.length) % uiFocusItems.length;
            applyUiFocus();
        }

        function scrollTimeline(amount) {
            if (!timelineScroll) return;
            timelineScroll.scrollTop = Math.max(0, timelineScroll.scrollTop + amount);
        }

        function activateUiFocus() {
            if (!uiFocusItems.length) return;
            const el = uiFocusItems[uiFocusIndex];
            if (el.tagName === 'TEXTAREA') {
                el.focus();
                return;
            }
            if (typeof el.click === 'function') {
                el.click();
            }
        }

        function applyPadToUi(pad) {
            const { x, y, dir } = readPadAxes(pad);
            if (!timelineModal.classList.contains('hidden') && timelineScroll) {
                if (Math.abs(y) > 0.2) {
                    scrollTimeline(-y * 30);
                }
            }
            let vertSign = 0;
            if (Math.abs(y) > Math.abs(x)) {
                if (y > 0.35) vertSign = -1; // up
                else if (y < -0.35) vertSign = 1; // down
            }
            if (vertSign !== 0 && vertSign !== uiPrevVert) {
                moveUiFocus(vertSign);
            }
            uiPrevVert = vertSign;
            if (edgePressed(pad, heroPrevButtons, 0)) {
                activateUiFocus();
            }
            // B button to cancel/close if available
            // B button no-op on decision modal now
            // Refresh focus list when UI visible
            buildUiFocusList();
        }


        function onResize() {
            if (!renderer || !camera) return;
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        function onMoveKey(axis) {
            if (!timelineModal.classList.contains('hidden') && timelineScroll) {
                scrollTimeline(-axis[1] * 40);
                return;
            }
            if (heroFrozen || jumpPrimed || pendingJump || isJumping) {
                keyAxis = [0, 0];
                return;
            }
            keyAxis = axis.slice(0);
        }

        function onAllyMoveKey(axis) {
            allyAxis = axis.slice(0);
        }

        function updatePhysicsWorld() {
            if (heroDead) return;
            if (isHeroOutOfBounds()) {
                triggerHeroDeath();
                return;
            }
            if ((isJumping || heroFrozen || rollingActive) && wBall) {
                wBall.SetLinearVelocity(new b2Vec2(0, 0));
            }
            if (liftGrabActive && wBall) {
                wBall.SetLinearVelocity(new b2Vec2(0, 0));
            }
            const lv = wBall.GetLinearVelocity();
            lv.Multiply(0.95);
            wBall.SetLinearVelocity(lv);

            const force = new b2Vec2(keyAxis[0] * wBall.GetMass() * 0.25, keyAxis[1] * wBall.GetMass() * 0.25);
            if (!isJumping && !rollingActive) {
                wBall.ApplyImpulse(force, wBall.GetPosition());
            }
            keyAxis = [0, 0];
            if (!liftGrabActive) {
                updateAllyMovement(1 / 60);
            }
            applyProximityEffects();

            wWorld.Step(1 / 60, 8, 3);
        }

        function triggerHeroDeath() {
            if (heroDead) return;
            heroDead = true;
            gamePhase = 'timeline';
            if (wBall) {
                wBall.SetLinearVelocity(new b2Vec2(0, 0));
            }
            rollingActive = false;
            keyAxis = [0, 0];
            showToast("You crossed the edge – life ends here");
            // show life recap
            showTimeline().catch(() => {});
        }

        function isHeroOutOfBounds() {
            if (!wBall || !mazeData?.grid_size) return false;
            const pos = wBall.GetPosition();
            const gw = mazeData.grid_size.width;
            const gh = mazeData.grid_size.height;
            return pos.x < 0 || pos.y < 0 || pos.x > gw - 1 || pos.y > gh - 1;
        }

        function updateAllyMovement(dt) {
            if (!allyBody) return;
            if (isAllyJumping) {
                allyBody.SetLinearVelocity(new b2Vec2(0, 0));
                return;
            }
            if (liftGrabActive) {
                allyBody.SetLinearVelocity(new b2Vec2(0, 0));
                return;
            }
            const vel = allyBody.GetLinearVelocity();
            vel.Multiply(0.95);
            allyBody.SetLinearVelocity(vel);

            const impulse = new b2Vec2(
                allyAxis[0] * allyBody.GetMass() * 0.25,
                allyAxis[1] * allyBody.GetMass() * 0.25
            );
            allyBody.ApplyImpulse(impulse, allyBody.GetWorldCenter());
            allyAxis = [0, 0];
        }

        function applyProximityEffects() {
            if (!allyBody || !wBall) return;
            if (liftGrabActive || isJumping || allyDisabledDuringHeroJump) return;
            const heroPos = wBall.GetPosition();
            const allyPos = allyBody.GetPosition();
            const dx = heroPos.x - allyPos.x;
            const dy = heroPos.y - allyPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const desiredDistance = ballRadius * 1.8;
            if (dist > 0 && dist < desiredDistance) {
                const nx = dx / dist;
                const ny = dy / dist;
                const heroVel = wBall.GetLinearVelocity();
                const allyVel = allyBody.GetLinearVelocity();
                const relativeNormal = (heroVel.x - allyVel.x) * nx + (heroVel.y - allyVel.y) * ny;
                if (relativeNormal < 0) {
                    const e = Math.sqrt(2 / 3); // roughly 1/3 energy loss
                    const heroMass = wBall.GetMass();
                    const allyMass = allyBody.GetMass();
                    const invMass1 = heroMass > 0 ? 1 / heroMass : 0;
                    const invMass2 = allyMass > 0 ? 1 / allyMass : 0;
                    const impulseScalar = -(1 + e) * relativeNormal / (invMass1 + invMass2);
                    const impulse = new b2Vec2(impulseScalar * nx, impulseScalar * ny);
                    const heroImpulse = new b2Vec2(impulse.x * heroFrozenImpulseBoost, impulse.y * heroFrozenImpulseBoost);
                    wBall.ApplyImpulse(heroImpulse, wBall.GetWorldCenter());
                    allyBody.ApplyImpulse(new b2Vec2(-impulse.x, -impulse.y), allyBody.GetWorldCenter());
                }
                const penetration = (ballRadius * 2) - dist;
                if (penetration > 0) {
                    const heroMass = wBall.GetMass();
                    const allyMass = allyBody.GetMass();
                    const totalMass = heroMass + allyMass || 1;
                    const correction = penetration / 2;
                    const heroShift = correction * (allyMass / totalMass);
                    const allyShift = correction * (heroMass / totalMass);
                    wBall.SetPosition(new b2Vec2(heroPos.x + nx * heroShift, heroPos.y + ny * heroShift));
                    allyBody.SetPosition(new b2Vec2(allyPos.x - nx * allyShift, allyPos.y - ny * allyShift));
                }
            }
        }

        function updateRenderWorld() {
            const stepX = wBall.GetPosition().x - ballMesh.position.x;
            const stepY = wBall.GetPosition().y - ballMesh.position.y;
            ballMesh.position.x += stepX;
            ballMesh.position.y += stepY;

            ballMesh.rotation.y += stepX / ballRadius;
            ballMesh.rotation.x += -stepY / ballRadius;

            camera.position.x += (ballMesh.position.x + 5 - camera.position.x) * 0.04;
            camera.position.y += (ballMesh.position.y - 6 - camera.position.y) * 0.04;
            camera.position.z += (18 - camera.position.z) * 0.03;
            camera.lookAt(new THREE.Vector3(ballMesh.position.x, ballMesh.position.y, 0));

            light.position.x = ballMesh.position.x;
            light.position.y = ballMesh.position.y;
            light.position.z = ballMesh.position.z + 3;

            if (!isAllyJumping && allyBody && allyMesh) {
                if (!allyBlinkActive) {
                    const allyPos = allyBody.GetPosition();
                    const stepAx = allyPos.x - allyMesh.position.x;
                    const stepAy = allyPos.y - allyMesh.position.y;
                    allyMesh.position.x += stepAx;
                    allyMesh.position.y += stepAy;
                    allyMesh.position.z = ballRadius;
                    allyMesh.rotation.y += stepAx / ballRadius;
                    allyMesh.rotation.x += -stepAy / ballRadius;
                    if (allyGlow) {
                        allyGlow.position.set(allyMesh.position.x, allyMesh.position.y, ballRadius);
                    }
                }
            }
            if (freezeOverlay && freezeOverlay.visible) {
                freezeOverlay.position.set(ballMesh.position.x, ballMesh.position.y, ballMesh.position.z);
            }
            if (shieldMesh && shieldMesh.visible) {
                shieldMesh.position.set(ballMesh.position.x, ballMesh.position.y, ballMesh.position.z);
            }
        }

        function gameLoop() {
            const now = performance.now();
            const delta = (now - lastFrameTime) / 1000;
            lastFrameTime = now;
            updateWallHighlights(now);
            updateAllyJumpRecharge(delta);
            updateFreezeRecharge(delta);
            updateExpandRecharge(delta);
            updateDissolveRecharge(delta);
            updateLiftRecharge(delta);
            updateBlinkRecharge(delta);
            updateFreezeEffects(delta);
            updateExpandEffects(delta);
            updateLiftAnimations(delta);
            updateShieldVisual(delta);
            updateRolling(delta);
            processExpandRestores(now);
            processDissolveRestores(now);
            updateTrapVisuals(now);
            updateBlinkAnimation(delta);
            tickDecisionRotation(now);
            processGamepadInput();
            if (gamePhase !== 'timeline' && gamePhase !== 'dead') {
                mutateMaze(delta);
                if (isJumping) {
                    updateJumpAnimation(delta);
                }
                if (isAllyJumping) {
                    updateAllyJumpAnimation(delta);
                }
                updatePhysicsWorld();
                updateRenderWorld();
                animateMazeMesh(delta);
                renderer.render(scene, camera);
                if (!pendingJump && !isJumping) {
                    handleMovementTick();
                }
            } else {
                if (isJumping) {
                    updateJumpAnimation(delta);
                }
                if (isAllyJumping) {
                    updateAllyJumpAnimation(delta);
                }
                animateMazeMesh(delta);
                renderer.render(scene, camera);
            }
            requestAnimationFrame(gameLoop);
        }

        function updateAllyGlow(delta) {
            if (!allyGlow) return;
            const t = performance.now() * 0.005;
            const flicker = 0.15 * Math.sin(t * 2.7) + 0.08 * Math.sin(t * 4.3 + 1.2);
            allyGlow.material.opacity = 0.45 + flicker;
            allyGlow.material.emissiveIntensity = 2.2 + 1.0 * flicker;
            const scale = 1 + flicker * 0.25;
            allyGlow.scale.set(scale, scale, scale);
        }

        async function handleMovementTick() {
            if (!ballMesh || pendingMove || heroFrozen || heroDead || liftGrabActive || rollingActive) return;
            const nextCell = getCurrentCellFromBall();
            if (!nextCell) {
                triggerHeroDeath();
                return;
            }
            if (!currentCell) {
                currentCell = { x: nextCell.x, y: nextCell.y };
                serverCell = { ...currentCell };
                return;
            }
            if (nextCell.x === currentCell.x && nextCell.y === currentCell.y) {
                return;
            }
            if (isOfflineMoveState()) {
                recordOfflineMove(nextCell);
                return;
            }
            pendingMove = true;
            try {
                const response = await fetchJson('/api/player/move', {
                    method: 'POST',
                    body: JSON.stringify({ x: nextCell.x, y: nextCell.y }),
                });
                if (!response.valid) {
                    snapBallToCell(currentCell);
                } else {
                    currentCell = { ...response.position };
                    stateData.current_position = { ...response.position };
                    serverCell = { ...response.position };
                    if (response.hero_health !== undefined) {
                        heroHealth = response.hero_health;
            if (hudHealth) hudHealth.textContent = `${heroHealth}%`;
            checkHeroHealthDeath();
        }
                    if (response.trap_event) {
                        handleTrapEvent(response.trap_event);
                    }
                    const posKey = `${response.position.x},${response.position.y}`;
                    const marker = decisionMarkers.get(posKey);
                    const isActiveDecision = decisionActiveMap.has(posKey) || !!marker?.visible;
                    if (response.decision_node && !response.visited_before && isActiveDecision) {
                        setMarkerVisited(response.position.x, response.position.y);
                    }
                    if (response.decision_required && isActiveDecision) {
                        prepareDecision(response.position);
                    }
                }
            } catch (err) {
                showToast("Sync failed: " + err.message);
                snapBallToCell(currentCell);
            } finally {
                pendingMove = false;
            }
        }

        function handleJumpKeyDown(event) {
            if (decisionStatus !== 'idle' || gamePhase === 'timeline') {
                return;
            }
            if (event.code === 'Space') {
                jumpPrimed = true;
                allyJumpPrimed = true;
                event.preventDefault();
                return;
            }
            const direction = keyCodeToDirection(event.code) || allyKeyCodeToDirection(event.code);
            if (liftGrabActive) {
                if (direction) {
                    liftAimDirection = direction;
                    updateLiftAimVisual();
                    event.preventDefault();
                    return;
                }
                if (event.code === 'Space' || event.code === 'Enter') {
                    event.preventDefault();
                    confirmLiftThrow();
                    return;
                }
                if (event.code === 'KeyB') {
                    event.preventDefault();
                    confirmLiftRoll();
                    return;
                }
            }
            if (event.code === 'KeyB') {
                liftPrimed = true;
                event.preventDefault();
                return;
            }
            if (liftPrimed && direction) {
                event.preventDefault();
                attemptLiftStart(direction);
                liftPrimed = false;
                return;
            }
            if (jumpPrimed && direction) {
                event.preventDefault();
                attemptJump(direction);
                jumpPrimed = false;
                return;
            }
            const allyDirection = allyKeyCodeToDirection(event.code);
            if (allyJumpPrimed && allyDirection) {
                event.preventDefault();
                attemptAllyJump(allyDirection);
                allyJumpPrimed = false;
                return;
            }
        }

        function handleJumpKeyUp(event) {
            if (event.code === 'Space') {
                jumpPrimed = false;
                allyJumpPrimed = false;
            }
            if (event.code === 'KeyB') {
                // do not cancel while aiming; only cancel primed state
                if (!liftGrabActive) {
                    liftPrimed = false;
                }
            }
        }

        function keyCodeToDirection(code) {
            switch (code) {
                case 'ArrowUp':
                case 'KeyK':
                    return 'south'; // aligned with world coordinates; visually looks upward
                case 'ArrowDown':
                case 'KeyJ':
                    return 'north';
                case 'ArrowLeft':
                case 'KeyH':
                    return 'west';
                case 'ArrowRight':
                case 'KeyL':
                    return 'east';
                default:
                    return null;
            }
        }

        function allyKeyCodeToDirection(code) {
            switch (code) {
                case 'KeyW':
                    return 'south';
                case 'KeyS':
                    return 'north';
                case 'KeyA':
                    return 'west';
                case 'KeyD':
                    return 'east';
                default:
                    return null;
            }
        }

        function freezeKeyToDirection(code) {
            switch (code) {
                case 'ArrowUp':
                case 'KeyW':
                    return 'south';
                case 'ArrowDown':
                case 'KeyS':
                    return 'north';
                case 'ArrowLeft':
                case 'KeyA':
                    return 'west';
                case 'ArrowRight':
                case 'KeyD':
                    return 'east';
                default:
                    return null;
            }
        }

        async function attemptJump(direction) {
            if (heroFrozen) {
                showToast("Frozen – can't jump");
                return;
            }
            if (liftGrabActive) return;
            if (pendingJump || isJumping) return;
            if (decisionStatus !== 'idle') {
                showToast("Finish this choice first");
                return;
            }
            if (gamePhase === 'timeline') {
                showToast("Timeline replay – no jumps");
                return;
            }
            if (jumpCharges <= 0) {
                showToast("No jumps left");
                return;
            }
            // When hero jumps, clear ally jump priming to avoid mirrored jumps
            allyPadJumpPrimed = false;
            allyAxis = [0, 0];
            if (!currentCell) {
                showToast("Position unknown");
                return;
            }
            pendingJump = true;
            keyAxis = [0, 0];
            if (wBall) {
                wBall.SetLinearVelocity(new b2Vec2(0, 0));
            }
            const fromCell = { ...currentCell };
            try {
                const response = await fetchJson('/api/player/jump', {
                    method: 'POST',
                    body: JSON.stringify({ direction }),
                });
                if (!response.success) {
                    showToast(formatJumpError(response.reason));
                    return;
                }
                if (response.state) {
                    stateData = response.state;
                    updateHud(stateData);
                } else if (typeof response.remaining_charges === 'number') {
                    jumpCharges = response.remaining_charges;
                    updateJumpsHud();
                }
                const target = response.position;
                const posKey = `${target.x},${target.y}`;
                const marker = decisionMarkers.get(posKey);
                const isActiveDecision = decisionActiveMap.has(posKey) || !!marker?.visible;
                if (response.decision_node && !response.visited_before && isActiveDecision) {
                    setMarkerVisited(target.x, target.y);
                }
                currentCell = { ...target };
                stateData.current_position = { ...target };
                if (response.decision_required && isActiveDecision) {
                    prepareDecision(target);
                }
                startJumpAnimation(fromCell, target);
            } catch (err) {
                showToast("Jump failed: " + err.message);
            } finally {
                pendingJump = false;
                jumpPrimed = false;
            }
        }

        function attemptAllyJump(direction) {
            if (pendingAllyJump || isAllyJumping) return;
            if (allyJumpCharges <= 0) {
                showToast("Buddy is out of jumps");
                return;
            }
            const fromCell = getAllyCellFromBody();
            if (!fromCell) {
                showToast("Buddy position unknown");
                return;
            }
            const destination = findAllyJumpDestination(fromCell, direction);
            if (!destination) {
                showToast("No jump path that way");
                return;
            }
            pendingAllyJump = true;
            try {
                allyJumpCharges = Math.max(0, allyJumpCharges - 1);
                updateJumpsHud();
                startAllyJumpAnimation(fromCell, destination);
            } finally {
                pendingAllyJump = false;
            }
        }

        function handleFreezeKeyDown(event) {
            if (event.code === 'KeyR') {
                freezePrimed = true;
                event.preventDefault();
                return;
            }
            const direction = freezeKeyToDirection(event.code);
            if (freezePrimed && direction) {
                event.preventDefault();
                attemptFreeze(direction);
                freezePrimed = false;
            }
        }

        function handleFreezeKeyUp(event) {
            if (event.code === 'KeyR') {
                freezePrimed = false;
            }
        }

        function handleExpandKeyDown(event) {
            if (event.code === 'KeyF') {
                expandPrimed = true;
                event.preventDefault();
                return;
            }
            if (!expandPrimed) return;
            const direction = freezeKeyToDirection(event.code);
            if (direction) {
                event.preventDefault();
                attemptExpand(direction);
                expandPrimed = false;
            }
        }

        function handleExpandKeyUp(event) {
            if (event.code === 'KeyF') {
                expandPrimed = false;
            }
        }

        function attemptFreeze(direction) {
            if (freezeCharges <= 0) {
                showToast("Freeze charges empty");
                return;
            }
            if (liftGrabActive) return;
            const allyCell = getAllyCellFromBody();
            if (!allyCell) {
                showToast("Buddy position unknown");
                return;
            }
            const heroCell = currentCell || getCurrentCellFromBall();
            freezeCharges = Math.max(0, freezeCharges - 1);
            updateFreezeHud();
            showToast("Buddy casts freeze to stall your rise");
            const impact = computeFreezeImpact(allyCell, heroCell, direction);
            renderFreezeBeam(allyCell, direction, impact.beamLength, impact.offsetX, impact.offsetY);
            if (impact.hitHero) {
                applyHeroFreeze();
            } else {
                showToast("You resist the freeze and carry on");
            }
        }

        function attemptExpand(direction) {
            if (gamePhase === 'timeline') {
                showToast("Timeline mode can't use frontier");
                return;
            }
            if (liftGrabActive) return;
            if (expandCharges <= 0) {
                showToast("Frontier charges empty");
                return;
            }
            const allyCell = getAllyCellFromBody();
            if (!allyCell) {
                showToast("Buddy position unknown");
                return;
            }
            const result = carveExpandCorridor(allyCell, direction);
            if (!result) {
                expandCharges = Math.max(0, expandCharges - 1);
                updateExpandHud();
                showToast("No frontier to breach — nothing to reach");
                spawnExpandWaveEffect(allyCell, direction, [], 6);
                return;
            }
            expandCharges = Math.max(0, expandCharges - 1);
            updateExpandHud();
            showToast("Frontiers fall, friends stand tall!");
            spawnExpandWaveEffect(allyCell, direction, result.segments, result.maxDistance);
        }

        async function attemptDissolve() {
            if (gamePhase === 'timeline') {
                showToast("Cannot dissolve during recap");
                return;
            }
            if (liftGrabActive) return;
            if (dissolveCharges <= 0) {
                showToast("No dissolve charges");
                return;
            }
            const allyCell = getAllyCellFromBody();
            if (!allyCell) {
                showToast("Cannot locate ally");
                return;
            }
            const key = `${allyCell.x},${allyCell.y}`;
            const marker = decisionMarkers.get(key);
            const isActive = decisionActiveMap.has(key) || !!marker?.visible;
            if (!isActive) {
                showToast("No glow to dissolve here");
                return;
            }
            try {
                const res = await fetchJson('/api/ally/dissolve', {
                    method: 'POST',
                    body: JSON.stringify({ x: allyCell.x, y: allyCell.y }),
                });
                if (typeof res.remaining_charges === 'number') {
                    dissolveCharges = res.remaining_charges;
                } else if (res.dissolve_state?.charges !== undefined) {
                    dissolveCharges = res.dissolve_state.charges;
                } else {
                    dissolveCharges = Math.max(0, dissolveCharges - 1);
                }
                updateDissolveHud();
                const restoreAt = res.restore_at ? res.restore_at * 1000 : performance.now() + dissolveInterval * 1000;
                dissolveDecisionKey(key, restoreAt);
                showToast("Ally dissolved your growth chance!");
                if (res.dissolve_state?.dissolved) {
                    dissolvedMap.clear();
                    res.dissolve_state.dissolved.forEach(item => {
                        if (item && item.x !== undefined && item.y !== undefined) {
                            dissolvedMap.set(`${item.x},${item.y}`, (item.restore_at || 0) * 1000);
                        }
                    });
                }
            } catch (err) {
                showToast("Dissolve failed: " + err.message);
            }
        }

        async function attemptLiftStart(direction = liftAimDirection) {
            if (liftGrabActive) return;
            if (decisionStatus !== 'idle') {
                showToast("Finish this choice first");
                liftPrimed = false;
                return;
            }
            if (liftCharges <= 0) {
                showToast("No lift charges left");
                liftPrimed = false;
                return;
            }
            const heroCell = currentCell || getCurrentCellFromBall();
            const allyCell = getAllyCellFromBody();
            if (!heroCell || !allyCell) {
                showToast("Position unknown");
                liftPrimed = false;
                return;
            }
            // Require alignment: same row or column within 3 cells
            const dx = heroCell.x - allyCell.x;
            const dy = heroCell.y - allyCell.y;
            if (!((dy === 0 && Math.abs(dx) <= 2) || (dx === 0 && Math.abs(dy) <= 2))) {
                showToast("Out of reach — ally boost misses you");
                liftPrimed = false;
                return;
            }
            liftAimDirection = direction || 'east';
            try {
                const res = await fetchJson('/api/ally/lift/start', {
                    method: 'POST',
                    body: JSON.stringify({
                        hero_x: heroCell.x,
                        hero_y: heroCell.y,
                        ally_x: allyCell.x,
                        ally_y: allyCell.y,
                    }),
                });
                if (typeof res.remaining_charges === 'number') {
                    liftCharges = res.remaining_charges;
                    updateLiftHud();
                }
                startLiftAttract(heroCell, allyCell);
            } catch (err) {
                showToast("Lift failed: " + err.message);
                liftPrimed = false;
            }
        }

        async function attemptTrap(placeType) {
            if (gamePhase === 'timeline') return;
            await resyncTrapStateFromServer();
            if (trapCharges <= 0) {
                showToast("No trap charges");
                return;
            }
            const allyCell = getAllyCellFromBody();
            if (!allyCell) {
                showToast("Cannot locate ally");
                return;
            }
            try {
                const res = await fetchJson('/api/ally/trap', {
                    method: 'POST',
                    body: JSON.stringify({ type: placeType, x: allyCell.x, y: allyCell.y }),
                });
                if (typeof res.remaining_charges === 'number') {
                    trapCharges = res.remaining_charges;
                } else if (res.charges !== undefined) {
                    trapCharges = res.charges;
                } else {
                    trapCharges = Math.max(0, trapCharges - 1);
                }
                if (res.traps) {
                    stateData.ally_state = stateData.ally_state || {};
                    stateData.ally_state.trap = stateData.ally_state.trap || {};
                    stateData.ally_state.trap.traps = res.traps;
                    refreshTrapVisuals(res.traps);
                }
                updateTrapHud();
                showToast(placeType === 'mine' ? "Hidden mine armed!" : "Hidden medkit stashed!");
            } catch (err) {
                showToast("Trap failed: " + err.message);
                await resyncTrapStateFromServer();
            }
        }

        async function resyncTrapStateFromServer() {
            try {
                const st = await fetchJson('/api/state');
                stateData = st || stateData;
                if (st?.ally_state?.trap) {
                    trapCharges = st.ally_state.trap.charges ?? trapCharges;
                    updateTrapHud();
                    if (st.ally_state.trap.traps) {
                        refreshTrapVisuals(st.ally_state.trap.traps);
                    }
                }
            } catch (_) {
                // ignore sync failure; next state pull will catch up
            }
        }

        function startLiftAttract(heroCell, allyCell) {
            clearLiftVisuals();
            liftGrabActive = true;
            liftPrimed = false;
            liftAnchorCell = { ...allyCell };
            liftAttractAnim = {
                start: cellToTile(heroCell.x, heroCell.y),
                end: cellToTile(allyCell.x, allyCell.y),
                elapsed: 0,
                duration: 0.6,
            };
            if (wBall) {
                wBall.SetAwake(true);
                wBall.SetLinearVelocity(new b2Vec2(0, 0));
            }
            showToast("Oops! Partner grabbed me!");
        }

        function beginLiftAim() {
            if (!liftAnchorCell) return;
            liftAimDirection = liftAimDirection || 'east';
            updateLiftAimVisual();
        }

        function updateLiftAimVisual() {
            if (!liftAnchorCell || !scene) return;
            const fromTile = cellToTile(liftAnchorCell.x, liftAnchorCell.y);
            const dir = CELL_DIRS[liftAimDirection] || CELL_DIRS.east;
            const points = [];
            const maxDist = 6;
            for (let i = 0; i <= 12; i++) {
                const t = i / 12;
                const dist = maxDist * t;
                const x = fromTile.x + dir.dx * dist;
                const y = fromTile.y + dir.dy * dist;
                const z = 0.3 + Math.sin(Math.PI * t) * 1.8;
                points.push(new THREE.Vector3(x, y, z));
            }
            // Support older Three.js in Astray: build geometry manually
            const geometry = new THREE.Geometry();
            points.forEach(p => geometry.vertices.push(p));
            const material = new THREE.LineBasicMaterial({ color: 0xff3344, transparent: true, opacity: 0.9 });
            if (liftAimLine) {
                scene.remove(liftAimLine);
                if (liftAimLine.geometry?.dispose) liftAimLine.geometry.dispose();
                if (liftAimLine.material?.dispose) liftAimLine.material.dispose();
            }
            liftAimLine = new THREE.Line(geometry, material);
            scene.add(liftAimLine);
        }

        function clearLiftVisuals() {
            if (liftAimLine) {
                scene.remove(liftAimLine);
                if (liftAimLine.geometry?.dispose) liftAimLine.geometry.dispose();
                if (liftAimLine.material?.dispose) liftAimLine.material.dispose();
                liftAimLine = null;
            }
        }

        function ensureShieldMesh() {
            if (!scene || !ballMesh) return;
            if (!shieldMesh) {
                const geo = new THREE.SphereGeometry(ballRadius * 1.5, 24, 16);
                const mat = new THREE.MeshPhongMaterial({
                    color: 0x55ccff,
                    transparent: true,
                    opacity: 0.35,
                    emissive: 0x55ccff,
                    emissiveIntensity: 0.8,
                });
                shieldMesh = new THREE.Mesh(geo, mat);
                scene.add(shieldMesh);
            }
            shieldMesh.visible = true;
            shieldMesh.position.copy(ballMesh.position);
        }

        function updateShieldVisual(delta) {
            if (!shieldMesh) ensureShieldMesh();
            if (!shieldMesh) return;
            const now = Date.now();
            if (!shieldActive || !shieldEndsAt || now > shieldEndsAt) {
                shieldMesh.visible = false;
                shieldActive = false;
                shieldEndsAt = null;
                return;
            }
            shieldMesh.visible = true;
            shieldMesh.position.copy(ballMesh.position);
            // subtle pulse
            const t = (performance.now() % 1000) / 1000;
            const pulse = 1 + Math.sin(t * Math.PI * 2) * 0.08;
            shieldMesh.scale.set(pulse, pulse, pulse);
        }

        async function confirmLiftThrow() {
            if (!liftGrabActive || !liftAnchorCell) return;
            try {
                const res = await fetchJson('/api/ally/lift/throw', {
                    method: 'POST',
                    body: JSON.stringify({
                        ally_x: liftAnchorCell.x,
                        ally_y: liftAnchorCell.y,
                        direction: liftAimDirection,
                    }),
                });
                const target = res.position;
                rollingDir = (res.roll_direction || liftAimDirection || 'east');
                const startTile = cellToTile(liftAnchorCell.x, liftAnchorCell.y);
                const endTile = cellToTile(target.x, target.y);

                stateData = res.state || stateData;
            if (res.hero_health !== undefined) {
                heroHealth = res.hero_health;
                checkHeroHealthDeath();
            }
            updateHud(stateData);
            currentCell = { ...target };
                stateData.current_position = { ...target };
                pendingHeroDeath = !!res.hero_dead;

                liftThrowAnim = {
                    start: startTile,
                    end: endTile,
                    elapsed: 0,
                    duration: 0.75,
                };
                showToast("Partner launches me!");
                const posKey = `${target.x},${target.y}`;
                const marker = decisionMarkers.get(posKey);
                const isActiveDecision = decisionActiveMap.has(posKey) || !!marker?.visible;
                if (res.decision_node && !res.visited_before && isActiveDecision) {
                    setMarkerVisited(target.x, target.y);
                }
                if (res.decision_required && isActiveDecision) {
                    prepareDecision(target);
                }
                liftGrabActive = false;
                liftPrimed = false;
                liftAnchorCell = null;
                clearLiftVisuals();
            } catch (err) {
                showToast("Lift throw failed: " + err.message);
                liftGrabActive = false;
                clearLiftVisuals();
            }
        }

        function confirmLiftRoll() {
            if (!liftGrabActive || !liftAnchorCell) return;
            rollingDir = liftAimDirection || 'east';
            liftGrabActive = false;
            liftPrimed = false;
            liftAnchorCell = null;
            clearLiftVisuals();
            rollingActive = true;
            showToast("Partner drives you forward!");
        }

function carveExpandCorridor(originCell, dirKey) {
            if (!cellGrid || !mazeData?.wall_grid) return null;
            const dir = CELL_DIRS[dirKey];
            if (!dir) return null;
            const startTile = cellToTile(originCell.x, originCell.y);
            const maxSteps = Math.max(
                expandMaxDistance,
                (mazeData.width || 0) + (mazeData.height || 0) || expandMaxDistance
            );
            let currentX = originCell.x;
            let currentY = originCell.y;
            let steps = 0;
            while (steps < maxSteps) {
                const baseTile = cellToTile(currentX, currentY);
                const wallX = baseTile.x + dir.dx;
                const wallY = baseTile.y + dir.dy;
                const gridW = mazeData.grid_size?.width ?? 0;
                const gridH = mazeData.grid_size?.height ?? 0;
                if (
                    wallX < 0 ||
                    wallY < 0 ||
                    wallX >= gridW ||
                    wallY >= gridH
                ) {
                    break;
                }
                if (mazeData.wall_grid?.[wallX]?.[wallY]) {
                    const segments = [{
                        x: currentX,
                        y: currentY,
                        dirKey,
                        tile: { gridX: wallX, gridY: wallY },
                        sourceCell: { x: currentX, y: currentY },
                    }];
                    const travel = Math.max(
                        4,
                        Math.abs(wallX - startTile.x) + Math.abs(wallY - startTile.y) + 1
                    );
                    return {
                        segments,
                        maxDistance: travel,
                    };
                }
                currentX += dir.dx;
                currentY += dir.dy;
                steps += 1;
            }
            return null;
        }

        function renderExpandCollapse(segments) {
            if (!segments?.length) return;
            for (const seg of segments) {
                if (seg.tile) {
                    spawnCollapseEffect(seg.tile.gridX, seg.tile.gridY);
                }
            }
        }

        function applyExpandSegments(segments) {
            if (!segments?.length) return;
            const ops = [];
            let changed = false;
            for (const seg of segments) {
                if (openWallBetween(seg.x, seg.y, seg.dirKey)) {
                    changed = true;
                    ops.push({
                        x: seg.x,
                        y: seg.y,
                        direction: seg.dirKey,
                        action: 'open',
                    });
                }
            }
            if (!changed) {
                return;
            }
            updateWallGridFromCells({ applyDiff: true });
            if (ops.length) {
                enqueueWallMutations(ops);
            }
            renderExpandCollapse(segments);
            scheduleExpandRestoration(segments);
        }

        function spawnCollapseEffect(x, y) {
            if (!mazeMesh) return;
            const material = new THREE.MeshPhongMaterial({
                color: 0xffb56b,
                emissive: 0x331400,
                transparent: true,
                opacity: 0.85,
            });
            const mesh = new THREE.Mesh(wallGeometry, material);
            mesh.position.set(x, y, 0.5);
            mesh.scale.set(1, 1, 1);
            mazeMesh.add(mesh);
            collapseEffects.push({
                mesh,
                elapsed: 0,
                duration: 0.45,
                baseOpacity: material.opacity,
            });
        }

        function spawnExpandWaveEffect(allyCell, direction, segments, distance) {
            if (!scene) return;
            const dir = CELL_DIRS[direction] || { dx: 1, dy: 0 };
            const startTile = allyBody ? allyBody.GetPosition() : cellToTile(allyCell.x, allyCell.y);
            const geometry = new THREE.TorusGeometry(0.5, 0.07, 8, 24);
            const material = new THREE.MeshBasicMaterial({
                color: 0x79e0ff,
                transparent: true,
                opacity: 0.85,
                side: THREE.DoubleSide,
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = Math.PI / 2;
            mesh.position.set(startTile.x, startTile.y, 0.25);
            scene.add(mesh);
            const dirVec = {
                x: dir.dx === 0 ? 0 : Math.sign(dir.dx),
                y: dir.dy === 0 ? 0 : Math.sign(dir.dy),
            };
            expandWaveEffects.push({
                mesh,
                dir: dirVec,
                speed: 9,
                traveled: 0,
                maxDistance: Math.max(6, distance),
                baseOpacity: material.opacity,
                segments,
                triggered: false,
            });
        }

        function scheduleExpandRestoration(segments) {
            if (!segments?.length) return;
            expandRestoreQueue.push({
                segments: segments.map(seg => ({ x: seg.x, y: seg.y, dirKey: seg.dirKey })),
                restoreAt: performance.now() + expandRestoreDelay * 1000,
            });
        }

        function processExpandRestores(nowMs) {
            for (let i = expandRestoreQueue.length - 1; i >= 0; i--) {
                const batch = expandRestoreQueue[i];
                if (nowMs >= batch.restoreAt) {
                    restoreExpandBatch(batch.segments);
                    expandRestoreQueue.splice(i, 1);
                }
            }
        }

        function processDissolveRestores(nowMs) {
            for (const [key, restoreAt] of Array.from(dissolvedMap.entries())) {
                if (nowMs >= restoreAt) {
                    dissolvedMap.delete(key);
                    if (!decisionPool.includes(key)) {
                        decisionPool.push(key);
                    }
                    activateDecisionKey(key, nowMs);
                }
            }
        }

        function restoreExpandBatch(segments) {
            if (!segments?.length) return;
            let changed = false;
            for (const seg of segments) {
                if (closeWallBetween(seg.x, seg.y, seg.dirKey)) {
                    changed = true;
                }
            }
            if (changed) {
                updateWallGridFromCells({ applyDiff: true });
                const ops = segments.map(seg => ({
                    x: seg.x,
                    y: seg.y,
                    direction: seg.dirKey,
                    action: 'close',
                }));
                enqueueWallMutations(ops);
            }
        }

        function computeFreezeImpact(allyCell, heroCell, direction) {
            const dir = CELL_DIRS[direction];
            if (!dir) {
                return { hitHero: false, beamLength: 4, offsetX: 0, offsetY: 0 };
            }
            const startTile = cellToTile(allyCell.x, allyCell.y);
            let beamLength = 4;
            let hitHero = false;
            let offsetX = 0;
            let offsetY = 0;
            if (heroCell) {
                const adjacentRow = Math.abs(heroCell.y - allyCell.y) <= 1;
                const adjacentCol = Math.abs(heroCell.x - allyCell.x) <= 1;
                if (dir.dx !== 0 && adjacentRow && (dir.dx > 0 ? heroCell.x > allyCell.x : heroCell.x < allyCell.x)) {
                    const heroTile = cellToTile(heroCell.x, heroCell.y);
                    beamLength = Math.abs(heroTile.x - startTile.x) + ballRadius * 2;
                    offsetY = (heroCell.y - allyCell.y) * 2;
                    hitHero = true;
                } else if (dir.dy !== 0 && adjacentCol && (dir.dy > 0 ? heroCell.y > allyCell.y : heroCell.y < allyCell.y)) {
                    const heroTile = cellToTile(heroCell.x, heroCell.y);
                    beamLength = Math.abs(heroTile.y - startTile.y) + ballRadius * 2;
                    offsetX = (heroCell.x - allyCell.x) * 2;
                    hitHero = true;
                }
            }
            return { hitHero, beamLength: Math.max(2, beamLength), offsetX, offsetY };
        }

        function renderFreezeBeam(allyCell, direction, length, offsetX = 0, offsetY = 0) {
            if (!freezeBeam) return;
            const dirVec = {
                north: { x: 0, y: -1 },
                south: { x: 0, y: 1 },
                east: { x: 1, y: 0 },
                west: { x: -1, y: 0 },
            }[direction] || { x: 1, y: 0 };
            const startPos = allyBody ? allyBody.GetPosition() : cellToTile(allyCell.x, allyCell.y);
            freezeBeam.visible = true;
            freezeBeam.rotation.set(0, 0, dirVec.y !== 0 ? Math.PI / 2 : 0);
            freezeBeam.scale.set(length, 1, 1);
            freezeBeam.position.set(
                startPos.x + offsetX + dirVec.x * (length / 2),
                startPos.y + offsetY + dirVec.y * (length / 2),
                ballRadius
            );
            freezeBeamTimer = 0.25;
        }

        function applyHeroFreeze() {
            heroFrozen = true;
            heroFreezeTimer = 5;
            freezeOverlay.visible = true;
            freezeOverlay.position.set(ballMesh.position.x, ballMesh.position.y, ballMesh.position.z);
            if (wBall) {
                wBall.SetLinearVelocity(new b2Vec2(0, 0));
            }
            setHeroMassScale(0.2);
            heroFrozenImpulseBoost = 3.0;
            applyFreezeDamage();
        }

        function releaseHeroFreeze() {
            heroFrozen = false;
            if (freezeOverlay) {
                freezeOverlay.visible = false;
            }
            setHeroMassScale(1);
            heroFrozenImpulseBoost = 1;
        }

        function setHeroMassScale(scale) {
            heroMassScale = scale;
            if (heroFixture && wBall) {
                heroFixture.SetDensity(heroBaseDensity * scale);
                wBall.ResetMassData();
            }
        }

        function applyFreezeDamage() {
            const damage = Math.max(1, Math.round(100 * 0.05));
            heroHealth = Math.max(0, heroHealth - damage);
            if (hudHealth) {
                hudHealth.textContent = `${heroHealth}%`;
            }
            syncFreezeDamageToServer();
            checkHeroHealthDeath();
        }

        async function syncFreezeDamageToServer() {
            try {
                const res = await fetchJson('/api/ally/freeze/hit', {
                    method: 'POST',
                    body: JSON.stringify({ damage_percent: 5 }),
                });
                if (res.hero_health !== undefined) {
                    heroHealth = res.hero_health;
                    if (hudHealth) {
                        hudHealth.textContent = `${heroHealth}%`;
                    }
                }
            } catch (err) {
                console.warn('Freeze damage sync failed', err);
            }
        }

        function formatJumpError(reason) {
            switch (reason) {
                case 'no_charges':
                    return "No jumps left";
                case 'no_destination':
                    return "No landing that way";
                case 'invalid_direction':
                    return "Direction not allowed";
                case 'invalid_target':
                    return "Can't land there";
                default:
                    return "Jump unavailable";
            }
        }

        function getCurrentCellFromBall() {
            const tileX = nearestOdd(ballMesh.position.x);
            const tileY = nearestOdd(ballMesh.position.y);
            const cellX = Math.round((tileX - 1) / 2);
            const cellY = Math.round((tileY - 1) / 2);
            if (cellX < 0 || cellX >= mazeData.width || cellY < 0 || cellY >= mazeData.height) {
                return null;
            }
            return { x: cellX, y: cellY };
        }

        function updateAllyJumpRecharge(delta) {
            allyJumpTimer += delta;
            if (allyJumpTimer >= allyJumpInterval) {
                const gained = Math.floor(allyJumpTimer / allyJumpInterval);
                allyJumpCharges = Math.min(allyJumpMax, allyJumpCharges + gained);
                allyJumpTimer -= gained * allyJumpInterval;
                updateJumpsHud();
            }
        }

        function updateFreezeRecharge(delta) {
            freezeRechargeTimer += delta;
            if (!freezeInitialGranted) {
                if (freezeRechargeTimer >= freezeInitialDelay) {
                    freezeCharges = Math.min(3, freezeCharges + 2);
                    freezeRechargeTimer -= freezeInitialDelay;
                    freezeInitialGranted = true;
                    updateFreezeHud();
                }
            } else if (freezeRechargeTimer >= freezeInterval) {
                const gained = Math.floor(freezeRechargeTimer / freezeInterval);
                if (gained > 0) {
                    freezeCharges = Math.min(3, freezeCharges + gained);
                    freezeRechargeTimer -= gained * freezeInterval;
                    updateFreezeHud();
                }
            }
        }

        function updateFreezeEffects(delta) {
            if (heroFrozen) {
                heroFreezeTimer -= delta;
                if (heroFreezeTimer <= 0) {
                    releaseHeroFreeze();
                }
            }
            if (freezeBeamTimer > 0) {
                freezeBeamTimer -= delta;
                if (freezeBeamTimer <= 0 && freezeBeam) {
                    freezeBeam.visible = false;
                }
            }
        }

        function updateLiftRecharge(delta) {
            liftRechargeTimer += delta;
            if (liftRechargeTimer >= liftInterval) {
                const gained = Math.floor(liftRechargeTimer / liftInterval);
                if (gained > 0) {
                    const before = liftCharges;
                    liftCharges = Math.min(liftMaxCharges, liftCharges + gained);
                    liftRechargeTimer -= gained * liftInterval;
                    if (liftCharges !== before) {
                        updateLiftHud();
                    }
                }
            }
        }

        function updateExpandRecharge(delta) {
            expandRechargeTimer += delta;
            if (!expandInitialGranted) {
                if (expandRechargeTimer >= expandInitialDelay) {
                    expandCharges = Math.min(expandMaxCharges, expandCharges + expandBurstAmount);
                    expandRechargeTimer -= expandInitialDelay;
                    expandInitialGranted = true;
                    updateExpandHud();
                }
                return;
            }
            if (expandRechargeTimer >= expandInterval) {
                const cycles = Math.floor(expandRechargeTimer / expandInterval);
                if (cycles > 0) {
                    const before = expandCharges;
                    expandCharges = Math.min(
                        expandMaxCharges,
                        expandCharges + cycles * expandBurstAmount
                    );
                    expandRechargeTimer -= cycles * expandInterval;
                    if (expandCharges !== before) {
                        updateExpandHud();
                    }
                }
            }
        }

        function updateTrapRecharge(delta) {
            trapTimer += delta;
            if (trapCharges >= trapMax) {
                trapTimer = 0;
                return;
            }
            if (trapTimer >= trapInterval) {
                const gained = Math.floor(trapTimer / trapInterval);
                trapCharges = Math.min(trapMax, trapCharges + gained);
                trapTimer -= gained * trapInterval;
                updateTrapHud();
            }
        }

        function updateBlinkRecharge(delta) {
            blinkTimer += delta;
            if (blinkCharges >= blinkMax) {
                blinkTimer = 0;
                return;
            }
            if (blinkTimer >= blinkInterval) {
                const gained = Math.floor(blinkTimer / blinkInterval);
                blinkCharges = Math.min(blinkMax, blinkCharges + gained);
                blinkTimer -= gained * blinkInterval;
                updateBlinkHud();
            }
        }

        async function attemptEscape() {
            if (gamePhase === 'timeline') return;
            if (!heroFrozen && !liftGrabActive) {
                showToast("Escape works only when grabbed or frozen");
                return;
            }
            if (escapeCharges <= 0) {
                showToast("No escape charges");
                return;
            }
            try {
                const cell = getCurrentCellFromBall();
                const payload = {};
                if (cell) {
                    payload.x = cell.x;
                    payload.y = cell.y;
                }
                const res = await fetchJson('/api/hero/escape', { method: 'POST', body: JSON.stringify(payload) });
                if (typeof res.remaining_charges === 'number') {
                    escapeCharges = res.remaining_charges;
                    updateEscapeHud();
                }
                heroFrozen = false;
                if (freezeOverlay) freezeOverlay.visible = false;
                if (wBall) {
                    wBall.SetLinearVelocity(new b2Vec2(0, 0));
                    wBall.SetAwake(true);
                }
                // Cancel any lift/attract/throw/rolling state
                rollingActive = false;
                lastRollPos = null;
                liftGrabActive = false;
                liftAttractAnim = null;
                liftThrowAnim = null;
                liftAnchorCell = null;
                clearLiftVisuals();
                // Realign ball to the provided position from backend if returned
                const pos = res.position || (cell ? { x: cell.x, y: cell.y } : null);
                if (pos) {
                    snapBallToCell(pos);
                    currentCell = { ...pos };
                    serverCell = { ...pos };
                    if (!stateData) stateData = {};
                    stateData.current_position = { ...pos };
                }
                showToast("Broke free! Keep moving!");
            } catch (err) {
                showToast("Escape failed: " + err.message);
            }
        }

        async function attemptShield() {
            if (gamePhase === 'timeline') return;
            if (shieldActive && shieldEndsAt && shieldEndsAt > performance.now()) {
                showToast("Shield already up");
                return;
            }
            if (shieldCharges <= 0) {
                showToast("Shield exhausted");
                return;
            }
            try {
                const res = await fetchJson('/api/hero/shield', { method: 'POST', body: JSON.stringify({}) });
                if (typeof res.remaining_charges === 'number') {
                    shieldCharges = res.remaining_charges;
                    updateShieldHud();
                }
                const duration = res.duration || 10;
                const nowMs = Date.now();
                const activeUntil = res.active_until ? res.active_until * 1000 : nowMs + duration * 1000;
                shieldEndsAt = activeUntil;
                shieldActive = true;
                showToast("Shield up—stay sharp!");
                ensureShieldMesh();
            } catch (err) {
                showToast("Shield failed: " + err.message);
            }
        }

        function updateDissolveRecharge(delta) {
            dissolveTimer += delta;
            if (dissolveCharges >= dissolveMax) {
                dissolveTimer = 0;
                return;
            }
            if (dissolveTimer >= dissolveInterval) {
                const gained = Math.floor(dissolveTimer / dissolveInterval);
                if (gained > 0) {
                    dissolveCharges = Math.min(dissolveMax, dissolveCharges + gained);
                    dissolveTimer -= gained * dissolveInterval;
                    updateDissolveHud();
                }
            }
        }

        function updateExpandEffects(delta) {
            for (let i = collapseEffects.length - 1; i >= 0; i--) {
                const effect = collapseEffects[i];
                effect.elapsed += delta;
                const t = Math.min(effect.elapsed / effect.duration, 1);
                const squash = Math.max(0.05, 1 - t);
                effect.mesh.scale.set(1, squash, 1);
                effect.mesh.position.z = 0.5 - t * 0.3;
                if (effect.mesh.material) {
                    effect.mesh.material.opacity = Math.max(0, effect.baseOpacity * (1 - t));
                }
                if (t >= 1) {
                    if (mazeMesh) {
                        mazeMesh.remove(effect.mesh);
                    }
                    if (effect.mesh.material?.dispose) {
                        effect.mesh.material.dispose();
                    }
                    collapseEffects.splice(i, 1);
                }
            }
            for (let i = expandWaveEffects.length - 1; i >= 0; i--) {
                const wave = expandWaveEffects[i];
                const step = wave.speed * delta;
                wave.traveled += step;
                wave.mesh.position.x += wave.dir.x * step;
                wave.mesh.position.y += wave.dir.y * step;
                const growth = 1 + (wave.traveled / wave.maxDistance) * 1.5;
                wave.mesh.scale.set(growth, growth, growth);
                const remaining = Math.max(0, 1 - wave.traveled / wave.maxDistance);
                if (wave.mesh.material) {
                    wave.mesh.material.opacity = wave.baseOpacity * remaining;
                }
                if (!wave.triggered && wave.traveled >= wave.maxDistance) {
                    applyExpandSegments(wave.segments);
                    wave.triggered = true;
                }
                if (wave.traveled >= wave.maxDistance) {
                    scene.remove(wave.mesh);
                    if (wave.mesh.geometry && typeof wave.mesh.geometry.dispose === 'function') {
                        wave.mesh.geometry.dispose();
                    }
                    if (wave.mesh.material) {
                        if (Array.isArray(wave.mesh.material)) {
                            wave.mesh.material.forEach(m => typeof m.dispose === 'function' && m.dispose());
                        } else if (typeof wave.mesh.material.dispose === 'function') {
                            wave.mesh.material.dispose();
                        }
                    }
                    expandWaveEffects.splice(i, 1);
                }
            }
        }

        function updateLiftAnimations(delta) {
            if (liftAttractAnim) {
                liftAttractAnim.elapsed += delta;
                const t = Math.min(liftAttractAnim.elapsed / liftAttractAnim.duration, 1);
                const x = liftAttractAnim.start.x + (liftAttractAnim.end.x - liftAttractAnim.start.x) * t;
                const y = liftAttractAnim.start.y + (liftAttractAnim.end.y - liftAttractAnim.start.y) * t;
                if (wBall) {
                    wBall.SetPosition(new b2Vec2(x, y));
                    wBall.SetLinearVelocity(new b2Vec2(0, 0));
                    wBall.SetAwake(true);
                }
                if (ballMesh) {
                    const z = Math.sin(Math.PI * t) * (jumpArcHeight * 0.2) + ballRadius;
                    ballMesh.position.set(x, y, z);
                }
                if (t >= 1) {
                    liftAttractAnim = null;
                    if (liftAnchorCell) {
                        snapBallToCell(liftAnchorCell);
                    }
                    beginLiftAim();
                }
            } else if (liftGrabActive && !liftThrowAnim && !liftAimLine) {
                // safety: ensure aim appears even if attract was skipped
                beginLiftAim();
            }
            if (liftThrowAnim) {
                liftThrowAnim.elapsed += delta;
                const t = Math.min(liftThrowAnim.elapsed / liftThrowAnim.duration, 1);
                const x = liftThrowAnim.start.x + (liftThrowAnim.end.x - liftThrowAnim.start.x) * t;
                const y = liftThrowAnim.start.y + (liftThrowAnim.end.y - liftThrowAnim.start.y) * t;
                const z = Math.sin(Math.PI * t) * (jumpArcHeight * 0.7) + ballRadius;
                if (wBall) {
                    wBall.SetPosition(new b2Vec2(x, y));
                    wBall.SetLinearVelocity(new b2Vec2(0, 0));
                    wBall.SetAwake(true);
                }
                if (ballMesh) {
                    ballMesh.position.set(x, y, z);
                }
                if (t >= 1) {
                    liftThrowAnim = null;
                    // after throw, snap to current cell to finish arc
                    if (currentCell) snapBallToCell(currentCell);
                    if (pendingHeroDeath && !heroDead) {
                        pendingHeroDeath = false;
                        triggerHeroDeath();
                    }
                }
            }
        }

        function isWallAtWorld(wx, wy) {
            const gx = Math.round(wx);
            const gy = Math.round(wy);
            const key = `${gx},${gy}`;
            if (wallBodies.has(key)) return true;
            return !!mazeData?.wall_grid?.[gx]?.[gy];
        }

        function findNearestOpenCell(wx, wy, maxRadius = 2) {
            const baseTileX = nearestOdd(wx);
            const baseTileY = nearestOdd(wy);
            for (let r = 0; r <= maxRadius; r++) {
                for (let dx = -r; dx <= r; dx++) {
                    for (let dy = -r; dy <= r; dy++) {
                        if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
                        const tx = baseTileX + dx * 2;
                        const ty = baseTileY + dy * 2;
                        const cx = Math.round((tx - 1) / 2);
                        const cy = Math.round((ty - 1) / 2);
                        if (cx < 0 || cy < 0 || cx >= mazeData.width || cy >= mazeData.height) continue;
                        if (mazeData.wall_grid?.[tx]?.[ty]) continue;
                        return { cell: { x: cx, y: cy }, tile: { x: tx, y: ty } };
                    }
                }
            }
            return null;
        }

        function updateRolling(delta) {
            if (!rollingActive || !wBall) return;
            const dir = CELL_DIRS[rollingDir] || CELL_DIRS.east;
            const step = rollingSpeed * delta;
            const pos = wBall.GetPosition();
            let newX = pos.x + dir.dx * step;
            let newY = pos.y + dir.dy * step;
            if (!lastRollPos) {
                lastRollPos = { x: pos.x, y: pos.y };
            }
            const gw = mazeData?.grid_size?.width ?? 0;
            const gh = mazeData?.grid_size?.height ?? 0;
            // remember last safe position only (not used to snap back)
            if (newX < 0 || newY < 0 || newX > gw - 1 || newY > gh - 1) {
                rollingActive = false;
                triggerHeroDeath();
                return;
            }
            if (isWallAtWorld(newX, newY)) {
                rollingActive = false;
                const bounceDist = Math.max(rollingBounce, rollingMinClearance);
                const prev = lastRollPos || { x: pos.x, y: pos.y };
                // bounce slightly back from last position instead of snapping far away
                let bounceX = prev.x - dir.dx * rollingBounce;
                let bounceY = prev.y - dir.dy * rollingBounce;
                wBall.SetPosition(new b2Vec2(bounceX, bounceY));
                wBall.SetLinearVelocity(new b2Vec2(0, 0));
                wBall.SetAwake(true);
                if (ballMesh) {
                    ballMesh.position.set(bounceX, bounceY, ballRadius);
                }
                // If still inside wall, step a bit more back
                if (isWallAtWorld(bounceX, bounceY)) {
                    bounceX = prev.x - dir.dx * bounceDist;
                    bounceY = prev.y - dir.dy * bounceDist;
                    wBall.SetPosition(new b2Vec2(bounceX, bounceY));
                    if (ballMesh) ballMesh.position.set(bounceX, bounceY, ballRadius);
                }
                // restore control immediately
                liftGrabActive = false;
                rollingActive = false;
                lastRollSafeCell = null;
                lastRollPos = null;
                finalizeRollPosition();
                return;
            }
            wBall.SetPosition(new b2Vec2(newX, newY));
            wBall.SetLinearVelocity(new b2Vec2(0, 0));
            wBall.SetAwake(true);
            if (ballMesh) {
                ballMesh.position.set(newX, newY, ballRadius);
            }
            const deltaMove = Math.abs(newX - lastRollPos.x) + Math.abs(newY - lastRollPos.y);
            if (deltaMove < 0.01) {
                // barely moved -> likely pressed against wall, end rolling
                rollingActive = false;
                liftGrabActive = false;
                lastRollSafeCell = null;
                lastRollPos = null;
                finalizeRollPosition();
                return;
            }
            lastRollPos = { x: newX, y: newY };
        }

        async function finalizeRollPosition() {
            let cell = getCurrentCellFromBall();
            if (!cell) {
                triggerHeroDeath();
                return;
            }
            // 若当前位置落在墙体或卡住，寻找最近开放格
            const tile = cellToTile(cell.x, cell.y);
            if (mazeData.wall_grid?.[tile.x]?.[tile.y]) {
                const found = findNearestOpenCell(wBall.GetPosition().x, wBall.GetPosition().y, 3);
                if (found) {
                    cell = found.cell;
                }
            }
            currentCell = { ...cell };
            stateData.current_position = { ...cell };
            snapBallToCell(currentCell);
            try {
                const res = await fetchJson('/api/player/sync_position', {
                    method: 'POST',
                    body: JSON.stringify({ x: currentCell.x, y: currentCell.y }),
                });
                if (res?.state) {
                    stateData = res.state;
                    updateHud(stateData);
                }
            } catch (err) {
                console.warn('sync_position failed', err);
            }
            const posKey = `${cell.x},${cell.y}`;
            const marker = decisionMarkers.get(posKey);
            const isActiveDecision = decisionActiveMap.has(posKey) || !!marker?.visible;
            if (isActiveDecision && marker?.visible) {
                setMarkerVisited(cell.x, cell.y);
            }
            if (isActiveDecision) {
                prepareDecision(cell);
            }
            lastRollSafeCell = null;
            lastRollPos = null;
        }

        function findAllyJumpDestination(fromCell, dirKey) {
            const dir = CELL_DIRS[dirKey];
            if (!dir) return null;
            const candidates = [];
            for (let distance = 2; distance <= 3; distance++) {
                const tx = fromCell.x + dir.dx * distance;
                const ty = fromCell.y + dir.dy * distance;
                if (!cellGrid?.[ty]?.[tx]) continue;
                candidates.push({ x: tx, y: ty });
            }
            if (!candidates.length) return null;
            const idx = Math.floor(Math.random() * candidates.length);
            return candidates[idx];
        }

        function getAllyCellFromBody() {
            if (!allyBody) return null;
            const pos = allyBody.GetPosition();
            return getCellFromWorldPosition(pos.x, pos.y);
        }

        function nearestOdd(value) {
            return Math.round((value - 1) / 2) * 2 + 1;
        }

        function getCellFromWorldPosition(wx, wy) {
            const tileX = nearestOdd(wx);
            const tileY = nearestOdd(wy);
            const cellX = Math.round((tileX - 1) / 2);
            const cellY = Math.round((tileY - 1) / 2);
            if (cellX < 0 || cellX >= mazeData.width || cellY < 0 || cellY >= mazeData.height) {
                return null;
            }
            return { x: cellX, y: cellY };
        }

        function cellToTile(x, y) {
            return { x: x * 2 + 1, y: y * 2 + 1 };
        }

        function snapBallToCell(cell) {
            const tile = cellToTile(cell.x, cell.y);
            wBall.SetPosition(new b2Vec2(tile.x, tile.y));
            wBall.SetLinearVelocity(new b2Vec2(0, 0));
            ballMesh.position.set(tile.x, tile.y, ballRadius);
        }

        function snapAllyToCell(cell) {
            if (!allyBody || !cell) return;
            const tile = cellToTile(cell.x, cell.y);
            allyBody.SetPosition(new b2Vec2(tile.x, tile.y));
            allyBody.SetLinearVelocity(new b2Vec2(0, 0));
            if (allyMesh) {
                allyMesh.position.set(tile.x, tile.y, ballRadius);
            }
            if (allyGlow) {
                allyGlow.position.set(tile.x, tile.y, ballRadius);
            }
        }

        function startJumpAnimation(fromCell, toCell) {
            const startCell = fromCell || toCell;
            const startTile = cellToTile(startCell.x, startCell.y);
            const endTile = cellToTile(toCell.x, toCell.y);
            jumpAnimation = {
                start: startTile,
                end: endTile,
                elapsed: 0,
            };
            isJumping = true;
            // Temporarily disable ally body to avoid being pushed by jump interpolation
            if (allyBody && allyBody.IsActive()) {
                allyDisabledDuringHeroJump = true;
                allyBody.SetActive(false);
            }
        }

        function updateJumpAnimation(delta) {
            if (!jumpAnimation) return;
            jumpAnimation.elapsed += delta;
            const t = Math.min(jumpAnimation.elapsed / jumpAnimationDuration, 1);
            const posX = jumpAnimation.start.x + (jumpAnimation.end.x - jumpAnimation.start.x) * t;
            const posY = jumpAnimation.start.y + (jumpAnimation.end.y - jumpAnimation.start.y) * t;
            const height = Math.sin(Math.PI * t) * jumpArcHeight + ballRadius;
            if (wBall) {
                wBall.SetPosition(new b2Vec2(posX, posY));
                wBall.SetLinearVelocity(new b2Vec2(0, 0));
                wBall.SetAwake(true);
            }
            ballMesh.position.set(posX, posY, height);
            ballMesh.rotation.y += 0.12;
            ballMesh.rotation.x += 0.08;

            camera.position.x += (posX + 5 - camera.position.x) * 0.04;
            camera.position.y += (posY - 6 - camera.position.y) * 0.04;
            camera.position.z += (18 - camera.position.z) * 0.03;
            camera.lookAt(new THREE.Vector3(posX, posY, 0));

            light.position.x = posX;
            light.position.y = posY;
            light.position.z = height + 3;

            if (t >= 1) {
                isJumping = false;
                jumpAnimation = null;
                snapBallToCell(currentCell);
                // Reactivate ally body after jump
                if (allyBody && allyDisabledDuringHeroJump) {
                    allyBody.SetActive(true);
                }
                allyDisabledDuringHeroJump = false;
            }
        }

        function startAllyJumpAnimation(fromCell, toCell) {
            const startCell = fromCell || toCell;
            const startTile = cellToTile(startCell.x, startCell.y);
            const endTile = cellToTile(toCell.x, toCell.y);
            allyJumpAnimation = {
                start: startTile,
                end: endTile,
                elapsed: 0,
                targetCell: { ...toCell },
            };
            isAllyJumping = true;
            allyAxis = [0, 0];
            if (allyBody) {
                allyBody.SetLinearVelocity(new b2Vec2(0, 0));
            }
        }

        function updateAllyJumpAnimation(delta) {
            if (!allyJumpAnimation) return;
            allyJumpAnimation.elapsed += delta;
            const t = Math.min(allyJumpAnimation.elapsed / jumpAnimationDuration, 1);
            const posX = allyJumpAnimation.start.x + (allyJumpAnimation.end.x - allyJumpAnimation.start.x) * t;
            const posY = allyJumpAnimation.start.y + (allyJumpAnimation.end.y - allyJumpAnimation.start.y) * t;
            const height = Math.sin(Math.PI * t) * (jumpArcHeight * 0.8) + ballRadius * 0.8;
            if (allyBody) {
                allyBody.SetPosition(new b2Vec2(posX, posY));
                allyBody.SetLinearVelocity(new b2Vec2(0, 0));
                allyBody.SetAwake(true);
            }
            if (allyMesh) {
                allyMesh.position.set(posX, posY, height);
                allyMesh.rotation.y += 0.1;
                allyMesh.rotation.x += 0.07;
                if (allyGlow) {
                    allyGlow.position.set(posX, posY, ballRadius);
                }
            }
            if (t >= 1) {
                const destination = allyJumpAnimation.targetCell;
                isAllyJumping = false;
                allyJumpAnimation = null;
                snapAllyToCell(destination);
            }
        }

        function setMarkerVisited(x, y) {
            const key = `${x},${y}`;
            const marker = decisionMarkers.get(key);
            if (marker) {
                marker.visible = false;
            }
            decisionActiveMap.delete(key);
            decisionPool = decisionPool.filter(k => k !== key);
            const node = mazeData.decision_nodes.find(n => `${n.x},${n.y}` === key);
            if (node) node.visited = true;
            refillDecisionActives();
            scheduleActiveSync();
        }

        function isOfflineMoveState() {
            return decisionStatus === 'loading_question' || decisionStatus === 'waiting_review';
        }

        function recordOfflineMove(cell) {
            currentCell = { ...cell };
            stateData.current_position = { ...cell };
            offlineMoveQueue.push({ ...cell });
        }

        async function flushOfflineMoves() {
            if (!offlineMoveQueue.length) {
                return;
            }
            if (offlineSyncPromise) {
                await offlineSyncPromise;
                return;
            }
            const moves = offlineMoveQueue.splice(0);
            offlineSyncPromise = (async () => {
                let applied = 0;
                try {
                    for (const move of moves) {
                        const response = await fetchJson('/api/player/move', {
                            method: 'POST',
                            body: JSON.stringify(move),
                        });
                        if (!response.valid) {
                            currentCell = { ...response.position };
                            stateData.current_position = { ...response.position };
                            snapBallToCell(currentCell);
                            break;
                        }
                        applied += 1;
                        serverCell = { ...response.position };
                    }
                } catch (err) {
                    console.warn('Offline move sync failed', err);
                    offlineMoveQueue.unshift(...moves.slice(applied));
                } finally {
                    offlineSyncPromise = null;
                }
            })();
            await offlineSyncPromise;
        }


        async function prepareDecision(position) {
            if (decisionStatus !== 'idle') {
                showToast("Another decision is already open");
                return;
            }
            decisionStatus = 'loading_question';
            pendingDecisionPosition = position;
            showToast("AI is drafting a question...");
            try {
                selectedOption = null;
            decisionSubmit.disabled = false;
            decisionOptions.innerHTML = '';
            decisionQuestionBox.classList.remove('is-hidden');
            decisionWaitBox.classList.add('is-hidden');
            decisionReviewBox.classList.add('is-hidden');
            waitActions.classList.add('is-hidden');
            waitTitle.textContent = 'AI is crafting your review...';
            reviewReady = false;
            pendingReviewPayload = null;
            decisionQuestion = await fetchJson('/api/decision/start', {
                method: 'POST',
                body: JSON.stringify(position),
            });
                decisionStatus = 'showing_question';
                renderQuestion(decisionQuestion);
                decisionModal.classList.remove('hidden');
                buildUiFocusList();
                await flushOfflineMoves();
            } catch (err) {
                decisionStatus = 'idle';
                showToast("Question failed: " + err.message);
                await flushOfflineMoves();
            }
        }

        function renderQuestion(question) {
            const ageLabel = stateData?.age !== undefined ? `${stateData.age}` : 'your age';
            if (decisionIntro) {
                decisionIntro.textContent = `A life or moral dilemma for someone your age (${ageLabel}). If you were in it, what would you choose? Options aren’t good or bad—pick your answer.`;
            }
            decisionPrompt.textContent = question.prompt;
            decisionOptions.innerHTML = '';
            (question.options || []).forEach((opt, index) => {
                const button = document.createElement('button');
                button.textContent = `${index + 1}. ${opt}`;
                button.addEventListener('click', () => {
                    selectedOption = index;
                    decisionOptions.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                });
                decisionOptions.appendChild(button);
            });
            checkHeroHealthDeath();
        }

        async function submitDecision() {
            if (!decisionQuestion || decisionStatus !== 'showing_question') {
                return;
            }
            if (selectedOption === null || selectedOption === undefined) {
                showToast("Choose an option first");
                return;
            }
            decisionSubmit.disabled = true;
            decisionStatus = 'waiting_review';
            gamePhase = 'play';
            showToast("AI reviewing...");
            showWaitReflection();
            decisionQuestionBox.classList.add('is-hidden');
            decisionReviewBox.classList.add('is-hidden');
            decisionWaitBox.classList.remove('is-hidden');
            decisionModal.classList.remove('hidden');
            try {
                const payload = {
                    question_id: decisionQuestion.id,
                    choice_id: selectedOption,
                    free_text: null,
                };
                const result = await fetchJson('/api/decision/submit', {
                    method: 'POST',
                    body: JSON.stringify(payload),
                });
                stateData = result.state;
                updateHud(stateData);
                const review = result.review;
                const valueDelta = result.value_delta;
                const voices = result.voices;
                const reviewPayload = { review, valueDelta, voices };
                pendingTimeline = !!result.game_complete;
                decisionQuestion = null;
                decisionModal.classList.remove('hidden');
                reviewReady = true;
                pendingReviewPayload = reviewPayload;
                waitTitle.textContent = 'AI review is ready';
                waitActions.classList.remove('is-hidden');
                decisionStatus = 'waiting_review_ready';
                buildUiFocusList();
                await flushOfflineMoves();
                if (pendingDecisionPosition) {
                    setMarkerVisited(pendingDecisionPosition.x, pendingDecisionPosition.y);
                } else {
                    setMarkerVisited(currentCell.x, currentCell.y);
                }
                pendingDecisionPosition = null;
            } catch (err) {
                decisionStatus = 'showing_question';
                decisionModal.classList.remove('hidden');
                showToast("Submit failed: " + err.message);
                await flushOfflineMoves();
            } finally {
                decisionSubmit.disabled = false;
            }
        }

        function renderReview(payload) {
            const { review, valueDelta, voices } = payload;
            decisionQuestionBox.classList.add('is-hidden');
            decisionWaitBox.classList.add('is-hidden');
            decisionReviewBox.classList.remove('is-hidden');
            const growthText = review ? `Growth: ${review.growth_delta >= 0 ? '+' : ''}${review.growth_delta}` : 'Growth: --';
            const matchText = review ? `Reflection: ${Math.round(review.match_score * 100)}%` : 'Reflection: --';
            reviewGrowth.textContent = growthText;
            reviewScore.textContent = matchText;
            reviewFeedback.textContent = review?.feedback || '';

            reviewValues.innerHTML = '';
            const v = valueDelta || {};
            const valueMap = {
                Empathy: v.empathy ?? 0,
                Integrity: v.integrity ?? 0,
                Courage: v.courage ?? 0,
                Responsibility: v.responsibility ?? 0,
                Independence: v.independence ?? 0,
            };
            Object.entries(valueMap).forEach(([label, delta]) => {
                const tile = document.createElement('div');
                tile.className = 'review-tile';
                tile.innerHTML = `<strong>${label}</strong>${delta >= 0 ? '+' : ''}${delta}`;
                reviewValues.appendChild(tile);
            });

            const age = stateData?.age ?? 0;
            const isSenior = age >= 60;
            if (labelParents) labelParents.textContent = isSenior ? 'Child:' : 'Parents:';
            if (labelFuture) labelFuture.textContent = isSenior ? 'Past self:' : 'Future self:';
            if (isSenior) {
                voiceParents.textContent = voices?.child || '';
                voiceFriend.textContent = voices?.friend || '';
                voiceFuture.textContent = voices?.past_self || '';
            } else {
                voiceParents.textContent = voices?.parents || '';
                voiceFriend.textContent = voices?.friend || '';
                voiceFuture.textContent = voices?.future_self || '';
            }
        }

        async function closeDecisionModal() {
            decisionModal.classList.add('hidden');
            decisionQuestion = null;
            decisionStatus = 'idle';
            pendingDecisionPosition = null;
            if (reviewDelayTimer) {
                clearTimeout(reviewDelayTimer);
                reviewDelayTimer = null;
            }
            pendingReviewPayload = null;
            reviewReady = false;
            pendingHeroDeath = false;
            decisionQuestionBox.classList.remove('is-hidden');
            decisionWaitBox.classList.add('is-hidden');
            decisionReviewBox.classList.add('is-hidden');
            if (gamePhase !== 'timeline') {
                gamePhase = 'play';
            }
            await flushOfflineMoves();
            buildUiFocusList();
        }

        async function finishReview() {
            await closeDecisionModal();
            const shouldShowTimeline = pendingTimeline;
            pendingTimeline = false;
            if (shouldShowTimeline) {
                await showTimeline();
            }
        }

        function pickReflection(age) {
            const band = AGE_REFLECTIONS.find(item => age >= item.min && age <= item.max) || AGE_REFLECTIONS[AGE_REFLECTIONS.length - 1];
            if (!band || !band.lines || !band.lines.length) {
                return { en: "", cn: "" };
            }
            const idx = Math.floor(Math.random() * band.lines.length);
            return band.lines[idx];
        }

        function showWaitReflection() {
            const age = stateData?.age ?? 10;
            const band = AGE_REFLECTIONS.find(item => age >= item.min && age <= item.max) || AGE_REFLECTIONS[AGE_REFLECTIONS.length - 1];
            const { en, cn } = pickReflection(age);
            waitLabel.textContent = band ? `What life for ages ${band.min}-${band.max} is like` : 'What life at this age is like';
            waitEn.textContent = en;
            waitCn.textContent = cn;
            waitTitle.textContent = 'AI is crafting your review...';
            waitActions.classList.add('is-hidden');
            reviewReady = false;
            pendingReviewPayload = null;
        }

        async function showTimeline() {
            try {
                gamePhase = 'timeline';
                decisionModal.classList.add('hidden');
                decisionQuestion = null;
                decisionStatus = 'idle';
                pendingDecisionPosition = null;
                const data = await fetchJson('/api/timeline');
                timelineSummary.innerHTML = `
                    <p>Final age: ${data.summary.final_age} (${data.summary.stage_name})</p>
                    <p>Total growth: ${data.summary.total_growth}</p>
                    <p>Decisions made: ${data.summary.decisions}</p>
                    <p>Values — Emp:${data.summary.value_dimensions.empathy} Int:${data.summary.value_dimensions.integrity} Cou:${data.summary.value_dimensions.courage} Resp:${data.summary.value_dimensions.responsibility} Ind:${data.summary.value_dimensions.independence}</p>
                `;
                timelineList.innerHTML = '';
                timelineNarrative.innerHTML = '';
                timelineGrowth.innerHTML = '';
                if (data.summary.narrative) {
                    timelineNarrative.innerHTML = `<p>${data.summary.narrative}</p>`;
                }
                data.records.forEach(rec => {
                    const item = document.createElement('div');
                    item.className = 'timeline-item';
                    item.innerHTML = `
                        <h4>#${rec.index} Age ${rec.age} · ${rec.stage_name}</h4>
                        <p>Question: ${rec.question.prompt}</p>
                        <p>Answer: ${rec.answer.choice_text || ''} ${rec.answer.free_text || ''}</p>
                        <p>Growth: ${rec.review.growth_delta >= 0 ? '+' : ''}${rec.review.growth_delta} · Reflection ${Math.round(rec.review.match_score * 100)}%</p>
                        <p>Feedback: ${rec.review.feedback}</p>
                    `;
                    timelineList.appendChild(item);
                });
                if (data.growth_history && data.growth_history.length) {
                    const ghTitle = document.createElement('h4');
                    ghTitle.textContent = 'Value Growth History';
                    timelineGrowth.appendChild(ghTitle);
                    data.growth_history.forEach((g, idx) => {
                        const row = document.createElement('div');
                        row.className = 'timeline-item';
                        const v = g.value_delta || {};
                        row.innerHTML = `
                            <strong>#${idx + 1}</strong> Age ${g.age} · ${g.stage} — Δ Emp:${v.empathy ?? 0} Int:${v.integrity ?? 0} Cou:${v.courage ?? 0} Resp:${v.responsibility ?? 0} Ind:${v.independence ?? 0}<br/>
                            <em>${g.prompt}</em><br/>
                            <small>Parents: ${g.perspectives?.parents || ''}</small><br/>
                            <small>Friend: ${g.perspectives?.friend || ''}</small><br/>
                            <small>Future: ${g.perspectives?.future_self || ''}</small>
                        `;
                        timelineGrowth.appendChild(row);
                    });
                    timelineList.appendChild(timelineGrowth);
                }
                if (timelineScroll) {
                    timelineScroll.scrollTop = 0;
                }
                timelineModal.classList.remove('hidden');
                buildUiFocusList();
                stopDecisionRotation();
            } catch (err) {
                showToast("Timeline failed to load: " + err.message);
            }
        }

        function hideTimeline() {
            timelineModal.classList.add('hidden');
            gamePhase = 'play';
            initDecisionRotation();
            startUiLoop();
        }

        function restartGame() {
            window.location.reload();
        }

        function updateHud(state) {
            hudAge.textContent = state.age;
            if (hudStage) hudStage.textContent = state.stage_name || state.stage;
            if (hudGrowth) hudGrowth.textContent = state.total_growth;
            hudGoal.textContent = state.goal_age;
            hudProvider.textContent = state.ai_provider;
            if (state.hero_health !== undefined && hudHealth) {
                heroHealth = state.hero_health;
                hudHealth.textContent = `${heroHealth}%`;
                checkHeroHealthDeath();
            }
            if (state.hero_escape_charges !== undefined && hudEscapeVal) {
                escapeCharges = state.hero_escape_charges;
                updateEscapeHud();
            }
            if (state.shield) {
            shieldCharges = state.shield.charges ?? shieldCharges;
                shieldEndsAt = state.shield.active_until ? state.shield.active_until * 1000 : null;
                shieldActive = !!shieldEndsAt && shieldEndsAt > Date.now();
                if (!shieldEndsAt) {
                    shieldActive = false;
                }
                updateShieldHud();
            }
            if (state.value_dimensions) {
                hudEmpathy.textContent = state.value_dimensions.empathy ?? 0;
                hudIntegrity.textContent = state.value_dimensions.integrity ?? 0;
                hudCourage.textContent = state.value_dimensions.courage ?? 0;
                hudResp.textContent = state.value_dimensions.responsibility ?? 0;
                hudInd.textContent = state.value_dimensions.independence ?? 0;
            } else {
                hudEmpathy.textContent = hudIntegrity.textContent = hudCourage.textContent = hudResp.textContent = hudInd.textContent = '--';
            }
            if (typeof state.jump_charges === 'number') {
                jumpCharges = state.jump_charges;
                updateJumpsHud();
            } else {
                if (hudHeroJumps) hudHeroJumps.textContent = '--';
                if (hudAllyJumps) hudAllyJumps.textContent = '--';
            }
            if (state.ally_state?.jump_charges !== undefined) {
                allyJumpCharges = state.ally_state.jump_charges;
                allyJumpTimer = 0;
                updateJumpsHud();
            }
            if (state.ally_state?.freeze) {
                syncFreezeState(state.ally_state.freeze);
            } else {
                updateFreezeHud();
            }
            if (state.ally_state?.expand) {
                syncExpandState(state.ally_state.expand);
            } else {
                updateExpandHud();
            }
            if (state.ally_state?.blink) {
                syncBlinkState(state.ally_state.blink);
            } else {
                updateBlinkHud();
            }
            if (state.ally_state?.trap) {
                syncTrapState(state.ally_state.trap);
            } else {
                updateTrapHud();
            }
            if (state.ally_state?.dissolve) {
                syncDissolveState(state.ally_state.dissolve);
            } else {
                updateDissolveHud();
            }
            if (state.ally_state?.lift) {
                syncLiftState(state.ally_state.lift);
            } else {
                updateLiftHud();
            }
        }

        function syncFreezeState(info) {
            if (!info) return;
            freezeCharges = info.charges ?? freezeCharges;
            freezeInitialDelay = info.initial_delay ?? freezeInitialDelay;
            freezeInterval = info.interval ?? freezeInterval;
            freezeInitialGranted = info.initial_granted ?? freezeInitialGranted;
            freezeRechargeTimer = 0;
            updateFreezeHud();
        }

        function updateFreezeHud() {
            freezeCharges = Math.min(3, freezeCharges);
            if (hudFreeze) {
                hudFreeze.textContent = freezeCharges;
            }
            if (stateData?.ally_state?.freeze) {
                stateData.ally_state.freeze.charges = freezeCharges;
                stateData.ally_state.freeze.initial_granted = freezeInitialGranted;
            }
        }

        function syncExpandState(info) {
            if (!info) return;
            expandCharges = info.charges ?? expandCharges;
            expandInitialDelay = info.initial_delay ?? expandInitialDelay;
            expandInterval = info.interval ?? expandInterval;
            expandInitialGranted = info.initial_granted ?? expandInitialGranted;
            expandBurstAmount = info.burst_amount ?? expandBurstAmount;
            expandMaxCharges = info.max_charges ?? expandMaxCharges;
            expandRechargeTimer = 0;
            updateExpandHud();
        }

        function updateExpandHud() {
            expandCharges = Math.min(expandMaxCharges, Math.max(0, expandCharges));
            if (hudExpand) {
                hudExpand.textContent = expandCharges;
            }
            if (stateData?.ally_state) {
                stateData.ally_state.expand = stateData.ally_state.expand || {};
                stateData.ally_state.expand.charges = expandCharges;
                stateData.ally_state.expand.initial_granted = expandInitialGranted;
            }
        }

        function updateShieldHud() {
            shieldCharges = Math.max(0, shieldCharges);
            if (hudShield) {
                hudShield.textContent = shieldCharges;
            }
            const now = Date.now();
            if (shieldActive && shieldEndsAt && now > shieldEndsAt) {
                shieldActive = false;
                shieldEndsAt = null;
            }
            if (!shieldActive && shieldMesh) {
                shieldMesh.visible = false;
            }
        }

        function checkHeroHealthDeath() {
            if (heroDead) return;
            if (heroHealth !== undefined && heroHealth <= 0) {
                triggerHeroDeath();
            }
        }

        function syncDissolveState(info) {
            if (!info) return;
            dissolveCharges = info.charges ?? dissolveCharges;
            dissolveTimer = 0;
            if (info.interval) {
                // keep interval immutable constant fallback
            }
            if (info.max_charges !== undefined) {
                // dissolveMax is const; ignore runtime change
            }
            if (Array.isArray(info.dissolved)) {
                dissolvedMap.clear();
                info.dissolved.forEach(item => {
                    if (item && item.x !== undefined && item.y !== undefined) {
                        const key = `${item.x},${item.y}`;
                        const restoreAtMs = (item.restore_at || 0) * 1000;
                        dissolvedMap.set(key, restoreAtMs);
                    }
                });
            }
            dissolvedMap.forEach((restoreAt, key) => {
                dissolveDecisionKey(key, restoreAt);
            });
            updateDissolveHud();
        }

        function updateDissolveHud() {
            dissolveCharges = Math.min(dissolveMax, Math.max(0, dissolveCharges));
            if (hudDissolve) {
                hudDissolve.textContent = dissolveCharges;
            }
            if (stateData?.ally_state) {
                stateData.ally_state.dissolve = stateData.ally_state.dissolve || {};
                stateData.ally_state.dissolve.charges = dissolveCharges;
            }
        }

        function syncLiftState(info) {
            if (!info) return;
            liftCharges = info.charges ?? liftCharges;
            liftRechargeTimer = 0;
            updateLiftHud();
        }

        function updateLiftHud() {
            const hudLiftEl = document.getElementById('hud-lift');
            liftCharges = Math.min(liftMaxCharges, Math.max(0, liftCharges));
            if (hudLiftEl) {
                hudLiftEl.textContent = liftCharges;
            }
            if (stateData?.ally_state) {
                stateData.ally_state.lift = stateData.ally_state.lift || {};
                stateData.ally_state.lift.charges = liftCharges;
            }
        }

        function syncTrapState(info) {
            if (!info) return;
            trapCharges = info.charges ?? trapCharges;
            trapTimer = 0;
            if (Array.isArray(info.traps)) {
                refreshTrapVisuals(info.traps);
            }
            updateTrapHud();
        }

        function syncBlinkState(info) {
            if (!info) return;
            blinkCharges = info.charges ?? blinkCharges;
            blinkTimer = 0;
            updateBlinkHud();
        }

        function updateTrapHud() {
            trapCharges = Math.min(trapMax, Math.max(0, trapCharges));
            if (hudTrap) {
                hudTrap.textContent = trapCharges;
            }
            if (stateData?.ally_state) {
                stateData.ally_state.trap = stateData.ally_state.trap || {};
                stateData.ally_state.trap.charges = trapCharges;
            }
        }

        function updateBlinkHud() {
            blinkCharges = Math.min(blinkMax, Math.max(0, blinkCharges));
            if (hudBlink) {
                hudBlink.textContent = blinkCharges;
            }
            if (stateData?.ally_state) {
                stateData.ally_state.blink = stateData.ally_state.blink || {};
                stateData.ally_state.blink.charges = blinkCharges;
            }
        }

        function updateEscapeHud() {
            escapeCharges = Math.max(0, escapeCharges);
            if (hudEscapeVal) hudEscapeVal.textContent = escapeCharges;
            checkHeroHealthDeath();
        }

        function refreshTrapVisuals(traps) {
            const existingKeys = new Set(trapVisuals.keys());
            const now = Date.now() / 1000;
            traps.forEach(trap => {
                const key = `${trap.x},${trap.y}`;
                existingKeys.delete(key);
                const revealAt = trap.reveal_at ?? (trap.placed_at ? trap.placed_at + 30 : 0);
                const expiresAt = trap.expires_at ?? (trap.placed_at ? trap.placed_at + 60 : 0);
                if (expiresAt && expiresAt <= now) {
                    return;
                }
                const visible = trap.visible || (revealAt && revealAt <= now);
                if (visible) {
                    ensureTrapMesh(key, trap.type);
                }
            });
            // remove stale
            existingKeys.forEach(key => {
                const mesh = trapVisuals.get(key);
                if (mesh && mazeMesh) {
                    mazeMesh.remove(mesh);
                }
                trapVisuals.delete(key);
            });
        }

        function ensureTrapMesh(key, type) {
            if (trapVisuals.has(key) || !mazeMesh) return;
            const [cx, cy] = key.split(',').map(Number);
            const color = type === 'mine' ? 0xff4444 : 0x33ff88;
            const TrapGeo = THREE.BoxGeometry || THREE.CubeGeometry;
            const geom = new TrapGeo(0.4, 0.4, 0.1, 1, 1, 1);
            const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(cellToTile(cx, cy).x, cellToTile(cx, cy).y, 0.55);
            trapVisuals.set(key, mesh);
            mazeMesh.add(mesh);
        }

        function updateTrapVisuals(nowMs) {
            const traps = stateData?.ally_state?.trap?.traps;
            if (!traps || !mazeMesh) return;
            const nowSec = Date.now() / 1000;
            const activeKeys = new Set();
            traps.forEach(trap => {
                const key = `${trap.x},${trap.y}`;
                const revealAt = trap.reveal_at ?? (trap.placed_at ? trap.placed_at + 30 : 0);
                const expiresAt = trap.expires_at ?? (trap.placed_at ? trap.placed_at + 60 : 0);
                const expired = expiresAt && expiresAt <= nowSec;
                if (expired) {
                    const mesh = trapVisuals.get(key);
                    if (mesh) mazeMesh.remove(mesh);
                    trapVisuals.delete(key);
                    return;
                }
                const visible = trap.visible || (revealAt && revealAt <= nowSec);
                if (visible) {
                    ensureTrapMesh(key, trap.type);
                    activeKeys.add(key);
                }
            });
            for (const key of Array.from(trapVisuals.keys())) {
                if (!activeKeys.has(key)) {
                    const mesh = trapVisuals.get(key);
                    if (mesh) mazeMesh.remove(mesh);
                    trapVisuals.delete(key);
                }
            }
        }

        async function attemptBlink() {
            if (gamePhase === 'timeline') return;
            if (blinkCharges <= 0) {
                showToast("Blink is charging");
                return;
            }
            if (liftGrabActive) {
                liftGrabActive = false;
                clearLiftVisuals();
            }
            try {
                const res = await fetchJson('/api/ally/blink', {
                    method: 'POST',
                    body: JSON.stringify({}),
                });
                if (typeof res.remaining_charges === 'number') {
                    blinkCharges = res.remaining_charges;
                    updateBlinkHud();
                }
                if (res.position) {
                    const targetCell = res.position;
                    snapAllyToCell(targetCell);
                    startBlinkAnimation(targetCell);
                }
                showToast("Blink! Partner drops in!");
            } catch (err) {
                showToast("Blink failed: " + err.message);
            }
        }

        function startBlinkAnimation(targetCell) {
            const startZ = ballRadius * 8;
            const endTile = cellToTile(targetCell.x, targetCell.y);
            blinkAnim = {
                elapsed: 0,
                duration: 0.8,
                startZ,
                end: endTile,
                shadow: spawnBlinkShadow(endTile.x, endTile.y),
            };
            allyBlinkActive = true;
            if (allyMesh) {
                allyMesh.position.set(endTile.x, endTile.y, startZ);
                allyMesh.scale.set(1.1, 1.1, 1.1);
            }
            if (allyBody) {
                allyBody.SetPosition(new b2Vec2(endTile.x, endTile.y));
                allyBody.SetLinearVelocity(new b2Vec2(0, 0));
            }
        }

        function updateBlinkAnimation(delta) {
            if (!blinkAnim || !allyMesh) return;
            blinkAnim.elapsed += delta;
            const t = Math.min(blinkAnim.elapsed / blinkAnim.duration, 1);
            // ease-out
            const ease = 1 - Math.pow(1 - t, 3);
            const z = blinkAnim.startZ + (ballRadius - blinkAnim.startZ) * ease;
            allyMesh.position.set(blinkAnim.end.x, blinkAnim.end.y, z);
            if (allyBody) {
                allyBody.SetPosition(new b2Vec2(blinkAnim.end.x, blinkAnim.end.y));
                allyBody.SetAwake(true);
            }
            if (t >= 1) {
                blinkAnim = null;
                if (allyMesh) {
                    allyMesh.position.z = ballRadius;
                    allyMesh.scale.set(1, 1, 1);
                }
                allyBlinkActive = false;
            }
        }

        function spawnBlinkShadow(x, y) {
            if (!scene) return null;
            const ShadowGeo = THREE.CircleGeometry || THREE.RingGeometry || THREE.CylinderGeometry;
            let geom;
            if (ShadowGeo === THREE.CylinderGeometry) {
                geom = new ShadowGeo(0.35, 0.35, 0.02, 8, 1);
            } else {
                geom = new ShadowGeo(0.35, 16);
            }
            const mat = new THREE.MeshBasicMaterial({
                color: 0x111111,
                transparent: true,
                opacity: 0.0,
                side: THREE.DoubleSide,
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.set(x, y, 0.02);
            scene.add(mesh);
            const start = performance.now();
            const tick = () => {
                if (!blinkAnim) {
                    scene.remove(mesh);
                    if (geom.dispose) geom.dispose();
                    if (mat.dispose) mat.dispose();
                    return;
                }
                const t = Math.min((performance.now() - start) / (blinkAnim.duration * 1000), 1);
                mat.opacity = 0.3 * (1 - t) + 0.5 * t;
                requestAnimationFrame(tick);
            };
            requestAnimationFrame(tick);
            return mesh;
        }

        function handleTrapEvent(evt) {
            if (!evt) return;
            const { effect, hero_health, shield_active } = evt;
            if (hero_health !== undefined) {
                heroHealth = hero_health;
                if (hudHealth) hudHealth.textContent = `${heroHealth}%`;
            }
            const isBlocked = !!shield_active;
            if (isBlocked) {
                showToast("Shielded—nothing touches you!");
                spawnTrapEffect(effect === 'damage' ? 'damage' : 'heal');
            } else {
                if (effect === 'damage') {
                    showToast("Boom! You got burned!");
                    spawnTrapEffect('damage');
                } else {
                    showToast("Lucky heal! Keep rolling!");
                    spawnTrapEffect('heal');
                }
            }
            const posKey = `${currentCell?.x ?? ''},${currentCell?.y ?? ''}`;
            const mesh = trapVisuals.get(posKey);
            if (mesh && mazeMesh) {
                mazeMesh.remove(mesh);
                trapVisuals.delete(posKey);
            }
            if (stateData?.ally_state?.trap?.traps) {
                stateData.ally_state.trap.traps = stateData.ally_state.trap.traps.filter(
                    t => `${t.x},${t.y}` !== posKey
                );
            }
            checkHeroHealthDeath();
        }

        function spawnTrapEffect(mode) {
            if (!scene || !ballMesh) return;
            const geom = new THREE.SphereGeometry(0.4, 12, 12);
            const mat = new THREE.MeshBasicMaterial({
                color: mode === 'damage' ? 0xff5522 : 0x55ff88,
                transparent: true,
                opacity: 0.7,
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(ballMesh.position.x, ballMesh.position.y, ballMesh.position.z + 0.2);
            scene.add(mesh);
            const start = performance.now();
            const tick = () => {
                const t = (performance.now() - start) / 600;
                mesh.scale.set(1 + t, 1 + t, 1 + t);
                mesh.material.opacity = Math.max(0, 0.7 * (1 - t));
                if (t < 1) {
                    requestAnimationFrame(tick);
                } else {
                    scene.remove(mesh);
                    if (mesh.geometry && typeof mesh.geometry.dispose === 'function') {
                        mesh.geometry.dispose();
                    }
                    if (mesh.material) {
                        if (Array.isArray(mesh.material)) {
                            mesh.material.forEach(m => typeof m.dispose === 'function' && m.dispose());
                        } else if (typeof mesh.material.dispose === 'function') {
                            mesh.material.dispose();
                        }
                    }
                }
            };
            requestAnimationFrame(tick);
        }

        function updateJumpsHud() {
            const heroVal = typeof jumpCharges === 'number' ? jumpCharges : '--';
            const allyVal = typeof allyJumpCharges === 'number'
                ? Math.min(allyJumpMax, Math.max(0, allyJumpCharges))
                : '--';
            if (hudHeroJumps) {
                hudHeroJumps.textContent = heroVal;
            }
            if (hudAllyJumps) {
                hudAllyJumps.textContent = allyVal;
            }
        }

        function showToast(message) {
            toastEl.textContent = message;
            toastEl.style.opacity = 1;
            setTimeout(() => {
                toastEl.style.opacity = 0;
            }, 2500);
        }

        function showLoading(text) {
            loadingText.textContent = text;
            loadingMask.classList.remove('hidden');
        }

        function hideLoading() {
            loadingMask.classList.add('hidden');
        }

        async function fetchJson(path, options = {}) {
            const response = await fetch(API_BASE + path, {
                headers: { 'Content-Type': 'application/json' },
                ...options,
            });
            if (!response.ok) {
                const detail = await response.json().catch(() => ({}));
                throw new Error(detail.detail || response.statusText);
            }
            return response.json();
        }

        startContinueBtn.addEventListener('click', () => {
            if (startChoiceHandled) return;
            startChoiceHandled = true;
            startChoiceModal.classList.add('hidden');
            startWithExistingState();
        });

        startRestartBtn.addEventListener('click', () => {
            if (startChoiceHandled) return;
            startChoiceHandled = true;
            startChoiceModal.classList.add('hidden');
            restartFromServer();
        });

        decisionSubmit.addEventListener('click', submitDecision);
        waitView.addEventListener('click', () => {
            if (reviewReady && pendingReviewPayload) {
                renderReview(pendingReviewPayload);
                decisionStatus = 'showing_review';
                buildUiFocusList();
            }
        });
        reviewContinue.addEventListener('click', finishReview);
        timelineRestart.addEventListener('click', restartGame);

        boot();
    </script>
</body>

</html>

